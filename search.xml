<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[设计模式学习之观察者模式和发布订阅模式]]></title>
      <url>http://djl.pub/2018/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>要说起学习设计模式的动机实际上是为了准备面试，惭愧脸，但是也正是因为要面试所以促使我去学习，今天学习的就是观察者模式和发布订阅模式。<br><a id="more"></a></p>
<p>说起这两个模式确实很像，为了弄懂其中的不同点确实也花了不少功夫，主要参考了这篇博文<a href="https://www.cnblogs.com/lovesong/p/5272752.html" target="_blank" rel="external">观察者模式与发布/订阅模式区别</a>，另外一篇就是曾探的《JavaScript设计模式与开发实践》一书中的《发布订阅模式》。两者结合大有所获。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>首先来谈谈观察者模式，在观察者模式中，有两个角色一个是Subject，用来维护一个observer列表，另一个角色就是Observer（观察者），在Observer中定义了一个具体的update方法，用来执行相关操作。整个过程就是当某个值发生变化后，Subject调用notify方法（实际就是循环调用observerList中每个observer的update方法，并把新的值作为update的参数传递进去）。从中我们可以看出在Subject中直接调用了Observer中的方法，也就是说Subject和Observer的联系实际上是非常紧密的。</p>
<p>举个例子，现在有一个房东他要租房子，当有空房子的时候，他就会去通知曾经来询问的租户，那么这个时候房东就是直接知道租客的电话和需求（要住什么样的房子）的，也就是此时房东和租客之间实际上是存在联系的。</p>
<p>大致的流向图就像下面。<br><img src="http://on-img.com/chart_image/5b8ffcdfe4b06fc64ae6969e.png" alt="观察者模式"></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//观察者列表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObserverList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observerList = [];</div><div class="line">&#125;</div><div class="line">ObserverList.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.observerList.push( obj );</div><div class="line">&#125;;</div><div class="line">ObserverList.prototype.count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.observerList.length;</div><div class="line">&#125;;</div><div class="line">ObserverList.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params"> index </span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>( index &gt; <span class="number">-1</span> &amp;&amp; index &lt; <span class="keyword">this</span>.observerList.length )&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observerList[ index ];</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">ObserverList.prototype.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params"> obj, startIndex </span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i = startIndex;</div><div class="line">  <span class="keyword">while</span>( i &lt; <span class="keyword">this</span>.observerList.length )&#123;</div><div class="line">    <span class="keyword">if</span>( <span class="keyword">this</span>.observerList[i] === obj )&#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div><div class="line">ObserverList.prototype.removeAt = <span class="function"><span class="keyword">function</span>(<span class="params"> index </span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observerList.splice( index, <span class="number">1</span> );</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//目标</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers = <span class="keyword">new</span> ObserverList();</div><div class="line">&#125;</div><div class="line">Subject.prototype.addObserver = <span class="function"><span class="keyword">function</span>(<span class="params"> observer </span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers.add( observer );</div><div class="line">&#125;;</div><div class="line">Subject.prototype.removeObserver = <span class="function"><span class="keyword">function</span>(<span class="params"> observer </span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers.removeAt( <span class="keyword">this</span>.observers.indexOf( observer, <span class="number">0</span> ) );</div><div class="line">&#125;;</div><div class="line">Subject.prototype.notify = <span class="function"><span class="keyword">function</span>(<span class="params"> context </span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> observerCount = <span class="keyword">this</span>.observers.count();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; observerCount; i++)&#123;</div><div class="line">    <span class="keyword">this</span>.observers.get(i).update( context );</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//观察者</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>前面说到Subject和Observer联系是非常紧密的，因为我们要在Subject中调用Observer中的方法。那么发布订阅模式就可以解耦合，把调用的任务交给一个调度中心（中介），让调度中心去通知各个订阅者。</p>
<p>接着上面的例子。房东有钱后，自己变懒了，他不想每次有房源后，自己还要亲自打电话通知之前预留电话想要租房的租客，因为自己还要记住那些的租客的电话和需求（有钱了不想干这些活，我要躺着赚钱）。于是他就找到了中介，每次空出房子后，直接告诉中介我这里有什么样的房子，中介这里记录着哪些租客有着什么样的需求，中介再去联系有这样需求的租客。那么这里房东和未来可能的租客之间是没有联系的，房东从此不用自己再去亲自打电话去通知每一个有着这样需求的租客，只需要告诉中介一个人就行，中介去通知。那么整个过程就如下面这样</p>
<p><img src="http://on-img.com/chart_image/5b8ffe03e4b0534c9bcd459d.png" alt="发布订阅模式"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pubsub = &#123;&#125;;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">myObject</span>) </span>&#123;</div><div class="line">    <span class="comment">// Storage for topics that can be broadcast</span></div><div class="line">    <span class="comment">// or listened to</span></div><div class="line">    <span class="keyword">var</span> topics = &#123;&#125;;</div><div class="line">    <span class="comment">// An topic identifier</span></div><div class="line">    <span class="keyword">var</span> subUid = <span class="number">-1</span>;</div><div class="line">    <span class="comment">// Publish or broadcast events of interest</span></div><div class="line">    <span class="comment">// with a specific topic name and arguments</span></div><div class="line">    <span class="comment">// such as the data to pass along</span></div><div class="line">    myObject.publish = <span class="function"><span class="keyword">function</span>(<span class="params"> topic, args </span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> ( !topics[topic] ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> subscribers = topics[topic],</div><div class="line">            len = subscribers ? subscribers.length : <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (len--) &#123;</div><div class="line">            subscribers[len].func( topic, args );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// Subscribe to events of interest</span></div><div class="line">    <span class="comment">// with a specific topic name and a</span></div><div class="line">    <span class="comment">// callback function, to be executed</span></div><div class="line">    <span class="comment">// when the topic/event is observed</span></div><div class="line">    myObject.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params"> topic, func </span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!topics[topic]) &#123;</div><div class="line">            topics[topic] = [];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> token = ( ++subUid ).toString();</div><div class="line">        topics[topic].push(&#123;</div><div class="line">            <span class="attr">token</span>: token,</div><div class="line">            <span class="attr">func</span>: func</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> token;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// Unsubscribe from a specific</span></div><div class="line">    <span class="comment">// topic, based on a tokenized reference</span></div><div class="line">    <span class="comment">// to the subscription</span></div><div class="line">    myObject.unsubscribe = <span class="function"><span class="keyword">function</span>(<span class="params"> token </span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> m <span class="keyword">in</span> topics ) &#123;</div><div class="line">            <span class="keyword">if</span> ( topics[m] ) &#123;</div><div class="line">                <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, j = topics[m].length; i &lt; j; i++ ) &#123;</div><div class="line">                    <span class="keyword">if</span> ( topics[m][i].token === token ) &#123;</div><div class="line">                        topics[m].splice( i, <span class="number">1</span> );</div><div class="line">                        <span class="keyword">return</span> token;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;( pubsub ));</div></pre></td></tr></table></figure>
<p>这里为什么要用一个立即执行函数传递一个对象进去，因为我们可能房东有很多个，如果每多一个房东，中介都要去告诉房东中介的电话号码，那么中介也很累，中介也很聪明，直接把自己的电话写在墙上，房东来到中介所看墙上的中介联系方式就可以直接获得。subUid就是用于方便取消订阅操作的，假如有一天你租到了自己满意的房子，你就要打电话告诉中介，不要再给我这个号码打电话了，我已经租到房子了。（不然天天都要被中介骚扰了）</p>
<p>总结：观察者模式和发布订阅模式的区别应该就是当有房源消息的时候，到底是谁来通知租客，观察者是房东自己本人，而发布订阅则是中介。</p>
<h2 id="最后（欢迎大家关注我）"><a href="#最后（欢迎大家关注我）" class="headerlink" title="最后（欢迎大家关注我）"></a>最后（欢迎大家关注我）</h2><p><a href="http://djl.pub/">DJL箫氏个人博客</a><br><a href="https://github.com/djlxiaoshi/blog/issues" target="_blank" rel="external">博客GitHub地址</a><br><a href="https://www.jianshu.com/u/d8657fcf1678" target="_blank" rel="external">简书</a><br><a href="https://juejin.im/user/57183fcac4c9710054bc2fcf" target="_blank" rel="external">掘金</a></p>
<p>如果你觉得有所收获的话，欢迎点赞，欢迎到我的github上面star一下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于React的脚手架搭建]]></title>
      <url>http://djl.pub/2018/03/20/%E5%9F%BA%E4%BA%8EReact%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>为了能够在工作中更加快速的搭建起开发环境，所以在<a href="https://github.com/facebook/create-react-app" target="_blank" rel="external">create-react-app</a>的基础之上结合自身公司业务和个人习惯，搭建了个更加方便的脚手架。<a href="https://github.com/djlxiaoshi/react-work-cli" target="_blank" rel="external">GitHub地址</a><br><a id="more"></a></p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">react  // mvm框架</div><div class="line">typescipt // 开发语言</div><div class="line">sass // 预编译语言</div><div class="line">anti-mobile // UI框架</div><div class="line">axios // http请求</div><div class="line">react-router-dom // 路由</div></pre></td></tr></table></figure>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><pre><code>core // 存放一些工具代码和一些服务
environments  // 存放环境配置文件
pages // app页面存放文件
routing // 路由
components // 公共组件
</code></pre><h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><h4 id="1-配置typescript使用环境"><a href="#1-配置typescript使用环境" class="headerlink" title="1 配置typescript使用环境"></a>1 配置typescript使用环境</h4><p>首先我打算使用typescript作为开发语言，首先我们是用<a href="https://github.com/wmonk/create-react-app-typescript" target="_blank" rel="external">create-react-app</a>来作为基础的脚手架工具，按照github上面的操作方法，进行如下操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">npm install -g create-react-app</div><div class="line">create-react-app my-app --scripts-version=react-scripts-ts</div><div class="line">cd my-app/</div><div class="line">npm start</div></pre></td></tr></table></figure></p>
<p>这样当我们就可以通过<code>npm start</code>启动应用了</p>
<h4 id="配置scss-参考链接"><a href="#配置scss-参考链接" class="headerlink" title="配置scss   参考链接"></a>配置scss   <a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-a-css-preprocessor-sass-less-etc" target="_blank" rel="external">参考链接</a></h4><p><code>npm install --save node-sass-chokidar</code></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line"><span class="addition">+  "build-css": "node-sass-chokidar src/ -o src/",</span></div><div class="line"><span class="addition">+  "watch-css": "npm run build-css &amp;&amp; node-sass-chokidar src/ -o src/--watch --recursive",</span></div><div class="line">   "start": "react-scripts-ts start",</div><div class="line">   "build": "react-scripts-ts build",</div><div class="line">   "test": "react-scripts-ts test --env=jsdom",</div></pre></td></tr></table></figure>
<p>按照如上操作即可,然后再添加<code>src/**/*.css</code>在<code>.gitignore</code>文件中。接下来我们希望项目能够监测scss的变化，从而自动去编译scss文件，显然我们要用到<code>watch-css</code>和<code>build-css</code>这两个任务，我们可以使用<code>&amp;&amp;</code>操作符，但是这种跨平台性并不是很好，所以我们采用<code>npm-run-all</code>这个工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save npm-run-all</div></pre></td></tr></table></figure>
<p>然后进行如下修改<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   "scripts": &#123;</div><div class="line">     "build-css": "node-sass-chokidar src/ -o src/",</div><div class="line">     "watch-css": "npm run build-css &amp;&amp; node-sass-chokidar src/ -o src/ --watch --recursive",</div><div class="line"><span class="deletion">-    "start": "react-scripts-ts start",</span></div><div class="line"><span class="deletion">-    "build": "react-scripts-ts build",</span></div><div class="line"><span class="addition">+    "start-js": "react-scripts-ts start",</span></div><div class="line"><span class="addition">+    "start": "npm-run-all -p watch-css start-js",</span></div><div class="line"><span class="addition">+    "build-js": "react-scripts-ts build",</span></div><div class="line"><span class="addition">+    "build": "npm-run-all build-css build-js",</span></div><div class="line">     "test": "react-scripts-ts test --env=jsdom",</div><div class="line">     "eject": "react-scripts-ts eject"</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>ok,以上我们就搭建好了scss环境</p>
<h4 id="安装anti-mobile"><a href="#安装anti-mobile" class="headerlink" title="安装anti-mobile"></a>安装anti-mobile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install antd-mobile --save</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install react-app-rewired --save-dev</div></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">	"build-css": "node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/",</div><div class="line">	"watch-css": "npm run build-css &amp;&amp; node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/ --watch --recursive",</div><div class="line"><span class="addition">+	"start-js": "react-app-rewired start --scripts-version react-scripts-ts",</span></div><div class="line">    "start": "npm-run-all -p watch-css start-js",</div><div class="line"><span class="addition">+    "build-js": "react-app-rewired build --scripts-version react-scripts-ts",</span></div><div class="line">    "build": "npm-run-all build-css build-js",</div><div class="line"><span class="addition">+    "test": "react-app-rewired test --env=jsdom",</span></div><div class="line">    "eject": "react-scripts-ts eject"</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>这里由于我们使用的是typescript，所以<code>&quot;start-js&quot;: &quot;react-app-rewired start --scripts-version react-scripts-ts&quot;,</code>和<code>&quot;build-js&quot;: &quot;react-app-rewired build --scripts-version react-scripts-ts&quot;,</code>后面要加上<code>react-scripts-ts</code>。接下来我们实现按需加载<a href="https://ant.design/docs/react/use-in-typescript-cn" target="_blank" rel="external">参考链接</a></p>
<p>安装<code>npm install babel-plugin-import --save-dev</code> </p>
<p>更改<code>config-overrides.js</code>文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* config-overrides.js */</span></div><div class="line"><span class="keyword">const</span> tsImportPluginFactory = <span class="built_in">require</span>(<span class="string">'ts-import-plugin'</span>)</div><div class="line"><span class="keyword">const</span> &#123; getLoader &#125; = <span class="built_in">require</span>(<span class="string">"react-app-rewired"</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> tsLoader = getLoader(</div><div class="line">        config.module.rules,</div><div class="line">        rule =&gt;</div><div class="line">            rule.loader &amp;&amp;</div><div class="line">            <span class="keyword">typeof</span> rule.loader === <span class="string">'string'</span> &amp;&amp;</div><div class="line">            rule.loader.includes(<span class="string">'ts-loader'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    tsLoader.options = &#123;</div><div class="line">        <span class="attr">getCustomTransformers</span>: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</div><div class="line">            <span class="attr">before</span>: [ tsImportPluginFactory(&#123;</div><div class="line">                <span class="attr">libraryName</span>: <span class="string">'antd-mobile'</span>,</div><div class="line">                <span class="attr">libraryDirectory</span>: <span class="string">'es'</span>,</div><div class="line">                <span class="attr">style</span>: <span class="string">'css'</span>,</div><div class="line">            &#125;) ]</div><div class="line">        &#125;)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样我们就可以直接引入<code>import { Button } from &#39;antd-mobile&#39;;</code>不需要在前面引入<code>import &#39;antd-mobile/dist/antd-mobile.css&#39;;</code></p>
<p>当我们引入antd-mobile后可能会出现下列错误</p>
<blockquote>
<p>E:/MyProjects/frame-work-cli/my-app/node_modules/antd-mobile/lib/picker/PropsType.d.ts<br>  (7,15): Parameter ‘values’ implicitly has an ‘any’ type.</p>
</blockquote>
<p>找到node_modules/antd-mobile/lib/picker/PropsType.d.ts把<code>format?: (values) =&gt; void;</code>改成 <code>format?: (values: any) =&gt; void;</code>即可当然为了直接省事，直接在tsconfig.json设置<code>&quot;noImplicitAny&quot;: false</code>。</p>
<h4 id="4-开发环境切换配置"><a href="#4-开发环境切换配置" class="headerlink" title="4 开发环境切换配置"></a>4 开发环境切换配置</h4><p>现在公司一般都会有开发环境，预发布环境和正式环境，这些环境所对应的后端地址并不一样，所以我们要来进行一些配置方便切换。实现的思路就是读取命令行参数，根据参数把不同环境的配置文件的内容复制替换掉environment.js这个文件，这里我们用到了<a href="https://github.com/shelljs/shelljs" target="_blank" rel="external">shelljs</a>和<a href="https://github.com/kentcdodds/cross-env" target="_blank" rel="external">cross-env</a>(读取命令行参数)这两个js库。<br>创建<code>cp-environment.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">'shelljs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> env = process.env.NODE_ENV;</div><div class="line"><span class="keyword">const</span> src = <span class="string">`src/environments/environment.<span class="subst">$&#123;env&#125;</span>.ts`</span>;</div><div class="line"><span class="keyword">const</span> to = <span class="string">`src/environments/environment.ts`</span>;</div><div class="line"></div><div class="line">shell.cp(<span class="string">'-R'</span>, src, to);</div></pre></td></tr></table></figure>
<p>更改package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;build-css&quot;: &quot;node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/&quot;,</div><div class="line">    &quot;watch-css&quot;: &quot;npm run build-css &amp;&amp; node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/ --watch --recursive&quot;,</div><div class="line">    &quot;start-js&quot;: &quot;react-app-rewired start --scripts-version react-scripts-ts&quot;,</div><div class="line">    &quot;start&quot;: &quot;cross-env NODE_ENV=pro npm-run-all cp-environment -p watch-css start-js&quot;,</div><div class="line">    &quot;startDev&quot;: &quot;cross-env NODE_ENV=dev npm-run-all cp-environment -p watch-css start-js&quot;,</div><div class="line">    &quot;startLocal&quot;: &quot;cross-env NODE_ENV=local npm-run-all cp-environment -p watch-css start-js&quot;,</div><div class="line">    &quot;build-js&quot;: &quot;react-app-rewired build --scripts-version react-scripts-ts&quot;,</div><div class="line">    &quot;build&quot;: &quot;cross-env NODE_ENV=pro npm-run-all cp-environment build-css build-js&quot;,</div><div class="line">    &quot;buildLocal&quot;: &quot;cross-env NODE_ENV=Local npm-run-all cp-environment build-css build-js&quot;,</div><div class="line">    &quot;buildDev&quot;: &quot;cross-env NODE_ENV=dev npm-run-all cp-environment build-css build-js&quot;,</div><div class="line">    &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;,</div><div class="line">    &quot;eject&quot;: &quot;react-scripts-ts eject&quot;,</div><div class="line">    &quot;cp-environment&quot;: &quot;node cp-environment.js&quot;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>当然我们开发环境上传的代码应该是buildDev后的代码，但是有可能有时进行了误操作，把build后的代码上传上去，我们还可以写一个检测的脚本。<br>原理就是读取当前分支名，根据分知名和当前的环境变量进行对比。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> branchEnvMap = &#123;</div><div class="line">  <span class="attr">dev</span>: <span class="string">'dev'</span>,</div><div class="line">  <span class="attr">test</span>: <span class="string">'test'</span>,</div><div class="line">  <span class="attr">release</span>: <span class="string">'prod'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">'shelljs'</span>);</div><div class="line"><span class="keyword">const</span> branch = shell.exec(<span class="string">'git rev-parse --symbolic-full-name --abbrev-ref HEAD'</span>, &#123; <span class="attr">silent</span>: <span class="literal">true</span> &#125;).toString().trim();</div><div class="line"><span class="keyword">const</span> env = process.argv.slice(<span class="number">2</span>).toString().split(<span class="string">'='</span>)[<span class="number">1</span>].toString();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (branchEnvMap[branch] !== env) &#123;</div><div class="line">  shell.echo(<span class="string">'该分支对应的编译任务不是这个，请检查执行的命令!'</span>, branch, env);</div><div class="line">  shell.exit(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h4><p>用到就是<a href="https://github.com/axios/axios" target="_blank" rel="external">axios</a>，至于怎么用直接看我的<a href="">GitHub地址</a>就行，这里进行了一层封装，主要是对返回的结果进行统一的处理。</p>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>我用到的是<a href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-dom" target="_blank" rel="external">react-router-dom</a>,至于用法还是推荐看github，</p>
<h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><blockquote>
<p>1 E:/MyProjects/frame-work-cli/my-app/node_modules/@types/react-dom/node_modules/@types/react/index.d.ts<br>  (3631,13): Subsequent property declarations must have the same type.<br>  Property ‘a’ must be of type ‘DetailedHTMLProps<anchorhtmlattributes<htmlanchorelement>, HTMLAnchorElement&gt;’,<br>  but here has type ‘DetailedHTMLProps<anchorhtmlattributes<htmlanchorelement>, HTMLAnchorElement&gt;’.</anchorhtmlattributes<htmlanchorelement></anchorhtmlattributes<htmlanchorelement></p>
</blockquote>
<p>当我们启动应用的时候可能会出现如上错误，这是由于我们安装的<code>@types/react</code>和<code>@types/react-dom</code>版本并不怎么一致，<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/20863" target="_blank" rel="external">参考链接</a>， 例如下面的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;@types/react&quot;: &quot;^15.6.7&quot;,</div><div class="line">&quot;@types/react-dom&quot;: &quot;^16.0.3&quot;,</div></pre></td></tr></table></figure></p>
<p>所以我们可以换成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;@types/react&quot;: &quot;^16.0.36&quot;, </div><div class="line">&quot;@types/react-dom: &quot;^16.0.3&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>2 E:/MyProjects/frame-work-cli/my-app/node_modules/antd-mobile/lib/picker/PropsType.d.ts(7,15): Parameter ‘values’ implicitly has an ‘any’ type.</p>
</blockquote>
<p>  在tsconfig.json设置<code>&quot;noImplicitAny&quot;: false</code></p>
<blockquote>
<p>3 error TS1192: Module ‘“react”‘ has no default export.</p>
</blockquote>
<p> 设置 tsconfig.json “allowSyntheticDefaultImports”: true,</p>
<blockquote>
<p>4 expected parameter: ‘props’ to have a typedef</p>
</blockquote>
<p>在tslint.json设置typedef: false,这个属于tslint相关配置的问题，具体可以看文档</p>
<h4 id="最后（欢迎大家关注我）"><a href="#最后（欢迎大家关注我）" class="headerlink" title="最后（欢迎大家关注我）"></a>最后（欢迎大家关注我）</h4><p><a href="http://djl.pub/">DJL箫氏个人博客</a><br><a href="https://github.com/djlxiaoshi/blog/issues" target="_blank" rel="external">博客GitHub地址</a><br><a href="https://www.jianshu.com/u/d8657fcf1678" target="_blank" rel="external">简书</a><br><a href="https://juejin.im/user/57183fcac4c9710054bc2fcf" target="_blank" rel="external">掘金</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[This解读]]></title>
      <url>http://djl.pub/2018/03/13/This%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>在很长的一段时间之内，我一直以为作用域就是上下文，这也就对JavaScript中的this理解增加了很多麻烦，所以这篇文章开篇第一个要陈诉的概念就是作用域和上下文不是一个概念。作用域(scope) 是指变量的可访问性，上下文是来决定this。（注意执行期上下文指的是作用域，这是JavaScipt规范，所以得遵守）<br><a id="more"></a><br>在JavaScript中只有两种作用域，一种是全局作用域，另一个就是函数作用域。上下文则会this息息相关，而this是在运行的时候进行绑定的，它的上下文取决于函数在哪里被调用，this的绑定和函数声明的位置没有任何关系。</p>
<p>当一个函数被调用时，会创建一个活动记录（即执行上下文）。这个活动会包含函数在哪里被调用，函数的调用方法，传入的参数信息等信息。this就是记录的其中一个属性，会在函数的执行过程中用到。</p>
<p>当然这句话出自《你不知道的JavaScript（上卷）》，在这里强烈推荐这本书，字字珠玑。</p>
<blockquote>
<p><strong>再次强调</strong>：this实际上是在函数被调用的时候发生绑定，它指向什么完全取决于函数在哪里调用。</p>
</blockquote>
<h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>接下来我们看看函数调用包括哪几种情况，只有正确的知道函数调用的位置，才能正确的明白this的指向问题。</p>
<h3 id="默认绑定-全局调用"><a href="#默认绑定-全局调用" class="headerlink" title="默认绑定(全局调用)"></a>默认绑定(全局调用)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>以上就是默认绑定，foo函数是直接调用的。</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">b = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">b</span>: <span class="number">3</span>,</div><div class="line">    <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</div><div class="line">&#125;</div><div class="line">obj.foo(); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>这里为什么叫做隐式绑定，因为这个foo函数无论是在obj里面声明还是在obj外面声明，他实际上都是不属于obj这个对象的（obj只是记录了foo这个属性的引用值），但是最后在执行的时候this却被绑定到了obj这个对象上下文中。当然如果有多个对象链式调用，this只会绑定到最后一层。<code>obj2.obj1.foo()</code>，this是绑定到obj1这个对象上下文中。</p>
<p>当然这里有一个注意点<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">b</span>: <span class="number">3</span>,</div><div class="line">    <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = obj.foo;</div><div class="line"></div><div class="line">bar(); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>这里实际上bar直接是foo的引用，就相当于<code>var bar = obj.foo = foo</code>，我们打印一下可以发现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(bar === foo &amp;&amp; foo === obj.foo &amp;&amp; bar === obj.foo) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>所以此时就和第一种默认绑定一样，bar函数是直接在全局上下文中被调用的，所以this会指向全局。</p>
<p>还有一种就是嵌套函数了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">b = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">b</span>: <span class="number">3</span>,</div><div class="line">    <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'foo'</span>, <span class="keyword">this</span>.b);<span class="comment">// 3</span></div><div class="line">    foo2();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'foo2'</span>, <span class="keyword">this</span>.b); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line">obj.foo();</div></pre></td></tr></table></figure></p>
<p>实际上foo2也是直接被（window）调用了。</p>
<h3 id="显示绑定call，apply，bind"><a href="#显示绑定call，apply，bind" class="headerlink" title="显示绑定call，apply，bind"></a>显示绑定call，apply，bind</h3><p>通过call，apply，bind函数可以强制某个函数在哪个对象（或者上下文）中被调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">b = 2;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">    b: 3,</div><div class="line">    foo: foo</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo () &#123;</div><div class="line">    console.log(&apos;foo&apos;, this.b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo.call(obj); // 3</div></pre></td></tr></table></figure></p>
<p>当然如果你传入的是一个基本类型的值，那么JavaScript会把它转换成它的对象形式。</p>
<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>说到new操作符，就不得不说它的内部工作原理了，我们在执行new操作的时候究竟执行了什么。</p>
<blockquote>
<p>1 创建一个全新的对象 var obj = {}<br>2 这个新对象的原型会被执行[[原型]]连接 obj[[prototype]] = Fun.prototye<br>3 这个新对象会绑定到函数调用的this Fun.bind(obj)<br>4 如果函数没有返回其他对象，那么会返回这个新创建的对象 return obj;</p>
</blockquote>
<p>所以new绑定实质还是显式绑定。</p>
<p>总结一下我们可以按照下面的顺序进行判断</p>
<blockquote>
<p>1 函数是否在new中调用（new 绑定），如果是this绑定的就是返回的新对象<br>2 函数是否通过call、apply（显式绑定）如果是this绑定的是那个指定的对象<br>3 函数是否在某个上下文对象中调用（隐式绑定），如果是，this绑定的是那个上下文无关文法对象<br>4 如果都不是那么就是默认绑定，this绑定的就是全局对象或者undefined（严格模式）</p>
</blockquote>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h3><p>凡事总有例外，如果你把null、undefined作为this的绑定对象传入call、apply或者bind那么实际上，这些值在执行的时候会被忽略，实际使用的是默认绑定。那么什么情况下我们会去绑定一个null或者undefined的呢？一种就是用apply来展开一个数组，当然这种方法的确很实用(不过在ES6中出现了…操作符来展开数组)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a + b&#125;</div><div class="line">foo.apply(<span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>]);</div></pre></td></tr></table></figure></p>
<p>箭头函数，箭头函数中的this是根据外层作用域来决定this的，也就是说箭头函数中的this就和箭头函数在哪里声明有关系了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">3</span>,</div><div class="line">    <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">    &#125;;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> fun = foo.call(obj);</div><div class="line"></div><div class="line">fun(); <span class="comment">// 3 此时箭头函数的外层作用域为foo，foo函数的this被绑定在了obj对象上</span></div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">a = 2;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">    a: 3,</div><div class="line">    foo: foo</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arrowFun = () =&gt; &#123;</div><div class="line">    console.log(this.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo () &#123;</div><div class="line">    return arrowFun;    </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var fun = foo.call(obj);</div><div class="line"></div><div class="line">fun(); //2 箭头函数的外层作用域为全局作用域，全局作用域中的this指向全局上下文</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Angular4学习之依赖注入]]></title>
      <url>http://djl.pub/2017/12/26/Angular4%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>在一个项目中，组件和服务之间存在错综复杂的关系，为了最小程度的耦合，我们需要来管理组织这种关系，依赖注入就是管理这种关系的一种方式。<br><a id="more"></a></p>
<h2 id="为什么要使用依赖注入"><a href="#为什么要使用依赖注入" class="headerlink" title="为什么要使用依赖注入"></a>为什么要使用依赖注入</h2><p>在学习一个概念之前，我们必须要知道我们为什么要学习这个东西，这个东西究竟解决了什么问题。就好比这里讲到的，依赖注入究竟解决了什么问题。要解决这个问题，我们先来看看示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">  public engine: Engine;</div><div class="line">  public tires: Tires;</div><div class="line">  public description = <span class="string">'No DI'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.engine = <span class="keyword">new</span> Engine();</div><div class="line">    <span class="keyword">this</span>.tires = <span class="keyword">new</span> Tires();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Method using the engine and tires</span></div><div class="line">  drive() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.description&#125;</span> car with `</span> +</div><div class="line">      <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.engine.cylinders&#125;</span> cylinders and <span class="subst">$&#123;<span class="keyword">this</span>.tires.make&#125;</span> tires.`</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是来自angular官网的一段代码，我们可以看到一个<code>Car</code>类依赖于<code>Engine</code>和<code>Tires</code>这两个类，我们在<code>Car</code>的构造函数中去实例这两个依赖类。这有什么问题？如果有一天我们的<code>Tires</code>构造函数需要一个参数，那么我们必须要在<code>Car</code>的构造函数中去更改代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line">   <span class="keyword">this</span>.engine = <span class="keyword">new</span> Engine();</div><div class="line">   <span class="keyword">this</span>.tires = <span class="keyword">new</span> Tires(params);</div><div class="line"> &#125;</div><div class="line">]</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>这种代码是非常不灵活的。虽然我们可以进行如下结构调整</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">  public engine: Engine;</div><div class="line">  public tires: Tires;</div><div class="line">  public description = <span class="string">'No DI'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(engine, tires) &#123;</div><div class="line">    <span class="keyword">this</span>.engine = engine;</div><div class="line">    <span class="keyword">this</span>.tires = tires;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Method using the engine and tires</span></div><div class="line">  drive() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.description&#125;</span> car with `</span> +</div><div class="line">      <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.engine.cylinders&#125;</span> cylinders and <span class="subst">$&#123;<span class="keyword">this</span>.tires.make&#125;</span> tires.`</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car(<span class="keyword">new</span> Engine(), <span class="keyword">new</span> Tires())</div></pre></td></tr></table></figure>
<p>这样似乎解决了不灵活的问题，但是如果依赖项很多的话，我们都要去手动创建这些实例，也不太方便。其实创建依赖实例的过程完全可以交给一个专门的’工厂’来做，这就是angular里面的Injector。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li>在组件中使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">selector</span>: <span class="string">'app-heroes'</span>,</div><div class="line">  <span class="attr">providers</span>: [Engine, Tires],</div><div class="line">  <span class="attr">template</span>: <span class="string">`</span></div><div class="line">    &lt;h2&gt;Heroes&lt;/h2&gt;</div><div class="line">    &lt;app-hero-list&gt;&lt;/app-hero-list&gt;</div><div class="line">  `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroesComponent</span> </span>&#123;</div><div class="line">  construtor(private engine: Engine) &#123;</div><div class="line">    <span class="keyword">this</span>.engine.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Angular中，一般我们将这些公共的依赖都会一些一个服务里面。在上面的用法我们可以看到多了一个providers，另外就是在类的构造函数中增加了<code>private engine: Engine</code>我们就可以去使用engine这个实例了，在这个过程中，我们并没有去手动去创建依赖项的实例。这是因为angular的Injector帮我们自动创建了。在这里有一个比较形象的比喻就是，一个厨子（Injector）根据菜谱（providers）去做菜（依赖的实例），但是究竟做哪些菜呢，客人说了算（<code>private engine: Engine</code>也就是构造函数中的）</p>
<ul>
<li>在服务中使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"></div><div class="line">@Injectable()</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(private engine: Engine) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们的一个服务本身就依赖于其他依赖项，那么我们使用<code>@Injectable()</code>装饰器（即使一个服务并没有依赖于其他服务，我们也推荐加上@Injectable()装饰器），我们依然要提供providers。这里由于服务通常跟视图是没有具体的关系，所以这里我们不会引入<code>@component</code>装饰器，那么我们在哪里确定这个providers呢?我们可以在一个<code>module</code>中的providers属性中去定义，那么这个<code>module</code>中的所有组件都会去共用这一个实例，但是我们有时候我们不希望共用一个实例，而是一个新的实例，那么我们可以在这个组件中的providers中重新定义，这样我们就会得到一个新的实例。实际上这就是层级注入。利用层级注入我们既可以共用实例，也可以不共用实例非常方便。一般全局使用的服务，我们会注册在app.module模块之下，这样在整个应用中都可以使用。</p>
<p>在上面我们说过通过依赖注入创建的实例是可以实现共享的，我们证明一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Component, OnInit, ReflectiveInjector &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123;DependenceComponent&#125; <span class="keyword">from</span> <span class="string">'./dependence.component'</span>;</div><div class="line"></div><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">selector</span>: <span class="string">'app-service'</span>,</div><div class="line">  <span class="attr">templateUrl</span>: <span class="string">'./service.component.html'</span>,</div><div class="line">  <span class="attr">styleUrls</span>: [<span class="string">'./service.component.scss'</span>],</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">@Injectable()</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">let</span> injector = ReflectiveInjector.resolveAndCreate([Dependence]);</div><div class="line">    <span class="keyword">let</span> dependence1 = injector.get(Dependence);</div><div class="line">    <span class="keyword">let</span> dependence2 = injector.get(Dependence);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'dependence1 === dependence2'</span>, dependence1 === dependence2); <span class="comment">// true</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ngOnInit() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们可以看见打印出来的是<code>true</code>，这里我们采用的是手动创建实例，所以我们并不需要在providers中提供“菜谱”，实际上<code>resolveAndCreate</code>的参数就是一个<code>providers</code></p>
<h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><p>我们有四种配置注入过程，即使用类、使用工厂、使用值、使用别名</p>
<ul>
<li>使用类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">provide</span>: MyService, <span class="attr">useClass</span>: MyService&#125;</div></pre></td></tr></table></figure>
<p>这是我们最常见的情形在angular中，通常如果provide的值和useclass的值一样，我们可以简化为<code>[MyService]</code>。</p>
<ul>
<li>使用值<br>显然并不是每种情况，我们都需要注入一个类，有时候可以仅仅是一个值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">provide</span>: MyValue, <span class="attr">useValue</span>: <span class="number">12345</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用别名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">provide</span>: OldService, <span class="attr">useClass</span>: NewService&#125;</div></pre></td></tr></table></figure>
<p>如果我们有两个服务<code>OldService</code>和<code>NewService</code>接口都一致，出于某种原因，我们不得不使用<code>OldService</code>作为Token，但是我们又想使用<code>NewService</code>中的接口，那么我们就可以使用别名。</p>
<ul>
<li>使用存在的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ NewLogger,</div><div class="line">  <span class="comment">// Not aliased! Creates two instances of `NewLogger`</span></div><div class="line">  &#123; <span class="attr">provide</span>: OldLogger, <span class="attr">useClass</span>: NewLogger&#125;]</div></pre></td></tr></table></figure>
<p>这种情况下会创建两个NewLogger的实例，这显然不是我们想要的结果，这时我们就可以使用存在的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ NewLogger,</div><div class="line">  <span class="comment">// Alias OldLogger w/ reference to NewLogger</span></div><div class="line">  &#123; <span class="attr">provide</span>: OldLogger, <span class="attr">useExisting</span>: NewLogger&#125;]</div></pre></td></tr></table></figure>
<ul>
<li>使用工厂<br>如果我们的服务需要根据不同的输入值，做出不同的响应，那么就必须要接受一个参数，那么我们就必须使用工厂</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">provide</span>: MyService, <span class="attr">useFactory</span>: <span class="function">(<span class="params">user: User</span>) =&gt;</span> &#123;</div><div class="line">    user.isAdmin ? <span class="keyword">new</span> adminService : customService,</div><div class="line">    <span class="attr">deps</span>: [User]</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
<p>当使用工厂时，我们可以通过变量的不同值，去实例不同的类。也就是说我们需要根据不同的值返回不同的依赖实例的时候，那么我们就需要使用工厂。</p>
<h2 id="Options-、-Host"><a href="#Options-、-Host" class="headerlink" title="@Options 、@Host"></a>@Options 、@Host</h2><p>目前为止我们的依赖都是存在的，但是实际情况并不是总是这样。那么我们可以通过@Optional装饰器来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Optional &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="comment">// ....</span></div><div class="line"><span class="keyword">constructor</span>(</div><div class="line">    @Optional() private dependenceService: DependenceService</div><div class="line">) &#123;&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>但是这里DependenceService这个服务类的定义还是存在的，只是没有准备好，例如没有在providers中使用</p>
</blockquote>
<p>依赖查找的规则是按照注入器从当前组件向父级组件查找，直到找到这个依赖为止，但是如果限定查找路径截止在宿主组件，那么如果宿主组件中没有就会报错，我们可以通过@Host修饰器达到这一功能。</p>
<blockquote>
<p>如果一个组件注入了依赖项，那么这个组件就是这个依赖项的宿主组件，但是如果这个组件通过<code>ng-content</code>被嵌入到宿主组件，那么这个宿主组件就是该依赖项的宿主组件。</p>
</blockquote>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>当我们在构造函数中使用<code>private dependenceService: DependenceService</code>,injector就可以正确的知道我们要实例哪一个类，这是因为在这里<code>DependenceService</code>充当了Token的角色（也就是说类名是可以充当Token的），我们只需要在providers中去寻找具有相同Token的值就行，但是往往我们注入不是一个类，而是一个字符串，function或者对象。而这里string、方法名和对象是不能够充当Token的，那么这时我们就需要来手动创建一个Token:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; InjectionToken &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> APP_CONFIG = <span class="keyword">new</span> InjectionToken&lt;AppConfig&gt;(<span class="string">'app.config'</span>);</div><div class="line"></div><div class="line">providers: [&#123; <span class="attr">provide</span>: APP_CONFIG, <span class="attr">useValue</span>: HERO_DI_CONFIG &#125;]</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(@Inject(APP_CONFIG) config: AppConfig) &#123;</div><div class="line">  <span class="keyword">this</span>.title = config.title;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Inject 装饰器显示的声明所依赖对象的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Injectable()</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(private buffer: Buffer) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(@Inject(Buffer) private buffer: Buffer) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Javascript 异步编程]]></title>
      <url>http://djl.pub/2017/12/13/Javascript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，当第一段有了执行结果之后，再回过头执行第二段。JavaScript采用异步编程原因有两点，一是JavaScript是单线程，二是为了提高CPU的利用率。在提高CPU的利用率的同时也提高了开发难度，尤其是在代码的可读性上。<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-12-14/94900806.jpg" alt="JavaScript异步执行示意图"></p>
<h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><p>最开始我们在处理异步的时候，采用的是callback回调函数的方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">asyncFunction(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="comment">// todo</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在一般简单的情况下，这种方式是完全够用的，但是如果碰到稍微复杂的场景，就有些力不从心，例如当异步嵌套过多的时候。</p>
<h3 id="回调金字塔"><a href="#回调金字塔" class="headerlink" title="回调金字塔"></a>回调金字塔</h3><p>但是当我们的异步操作比较多，而且都依赖于上一步的异步的执行结果，那么我们就会产生回调金字塔，难于阅读<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</div><div class="line">    step2(<span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</div><div class="line">        step3(<span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</div><div class="line">            step4(<span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</div><div class="line">                <span class="comment">// Do something with value4</span></div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>当然为了改进这种层层嵌套的写法，我们有几种方式<br>1 命名函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span> (<span class="params">params</span>) </span>&#123;</div><div class="line">  <span class="comment">// todo</span></div><div class="line">  asyncFunction(fun2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span> (<span class="params">params</span>) </span>&#123;</div><div class="line">  <span class="comment">// todo</span></div><div class="line">  asyncFunction(fun3)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span> (<span class="params">params</span>) </span>&#123;</div><div class="line">  <span class="comment">// todo</span></div><div class="line">  asyncFunction(fun4)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun4</span> (<span class="params">params</span>) </span>&#123;</div><div class="line">  <span class="comment">// todo</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">asyncFunction(fun1)</div></pre></td></tr></table></figure>
<p>2 基于事件消息机制的写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">eventbus.on(<span class="string">"init"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    operationA(<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</div><div class="line">        eventbus.dispatch(<span class="string">"ACompleted"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">eventbus.on(<span class="string">"ACompleted"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    operationB(<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</div><div class="line">        eventbus.dispatch(<span class="string">"BCompleted"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">eventbus.on(<span class="string">"BCompleted"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    operationC(<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</div><div class="line">        eventbus.dispatch(<span class="string">"CCompleted"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">eventbus.on(<span class="string">"CCompleted"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// do something when all operation completed</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>当然也可以利用模块化来处理，使得代码易于阅读。以上这三种方式都只是在代码的可读性上面做了改进，但是并没有解决另外一个问题就是异常捕获。</p>
<h3 id="错误栈"><a href="#错误栈" class="headerlink" title="错误栈"></a>错误栈</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    b();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    c();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    d();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错啦'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">a();</div></pre></td></tr></table></figure>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-12-14/34642187.jpg" alt="Node错误打印"></p>
<p>从上面的图我们可以看到有一个比较清晰的错误栈信息，a调用b - b调用c - c调用d ，在d中抛出了一个异常。也就是说在JavaScript中在执行一个函数的时候首先会压入执行栈中，执行完毕后会移除执行栈，FILO的结构。我们可以很方便的从错误信息中定位到出错的地方。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    b();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    c(cb);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    setTimeout(callback, <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错啦'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">a();</div></pre></td></tr></table></figure>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-12-14/24038039.jpg" alt="包含异步的错误栈"></p>
<p>从上图我们可以看到只打印出了是在一个setTimeout中的回调函数中出现了异常，执行顺序是跟踪不到的。</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>回调函数中的异常是不能够捕捉到的，因为是异步的，我们只能在回调函数中使用try catch捕获，也就是我注释的部分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// try&#123;</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错啦'</span>);</div><div class="line">        <span class="comment">// &#125; catch (e) &#123;</span></div><div class="line">        </div><div class="line">        <span class="comment">// &#125;</span></div><div class="line">        </div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    a();</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉到异常啦，好高兴哦'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是try catch只能捕捉到同步的错误，不过在回调中也有一些比较好的错误处理模式，例如error-first的代码风格约定，这种风格在node.js中广泛被使用 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      func();</div><div class="line">      cb(<span class="literal">null</span>, params);</div><div class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">      cb(error);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="function"><span class="keyword">function</span>(<span class="params">error, value</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(error)&#123;</div><div class="line">        <span class="comment">// todo</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// todo</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是这么做也很容易陷入恶魔金字塔中。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="规范简述"><a href="#规范简述" class="headerlink" title="规范简述"></a><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="external">规范简述</a></h3><ul>
<li>promise 是一个拥有 then 方法的对象或函数。</li>
<li>一个promise有三种状态 pending, rejected, resolved 状态一旦确定就不能改变，且只能够由pending状态变成rejected或者resolved状态，reject和resolved状态不能相互转换。</li>
<li>当promise执行成功时，调用then方法的第一个回调函数，失败时调用第二个回调函数。</li>
<li>promise实例会有一个then方法，这个then方法必须返回一个新的promise。</li>
</ul>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步操作放在Promise构造器中</span></div><div class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        resolve(<span class="string">'hello'</span>);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 得到异步结果之后的操作</span></div><div class="line">promise1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value, <span class="string">'world'</span>);</div><div class="line">&#125;, error =&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(error, <span class="string">'unhappy'</span>)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="异步代码，同步写法"><a href="#异步代码，同步写法" class="headerlink" title="异步代码，同步写法"></a>异步代码，同步写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">asyncFun()</div><div class="line">    .then(cb)</div><div class="line">    .then(cb)</div><div class="line">    .then(cb)</div></pre></td></tr></table></figure>
<p>promise以这种链式写法，解决了回调函数处理多重异步嵌套带来的回调地狱问题，使代码更加利于阅读，当然本质还是使用回调函数。</p>
<h3 id="异常捕获-1"><a href="#异常捕获-1" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>前面说过如果在异步的callback函数中也有一个异常，那么是捕获不到的，原因就是回调函数是异步执行的。我们看看promise是怎么解决这个问题的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">asyncFun(<span class="number">1</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错啦'</span>);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'有错误'</span>, result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>其实是promise的then方法中，已经自动帮我们try catch了这个回调函数，实现大致如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        cb()</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">       <span class="comment">// todo</span></div><div class="line">       reject(e)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>then方法中抛出的异常会被下一个级联的then方法的第二个参数捕获到（前提是有），那么如果最后一个then中也有异常怎么办。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.then(resolve, reject).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">           <span class="keyword">throw</span> reason;</div><div class="line">        &#125;, <span class="number">0</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">asyncFun(<span class="number">1</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'then resolve回调出错啦'</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(error);</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'catch回调出错啦'</span>);</div><div class="line">&#125;).done(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;&#125;);</div></pre></td></tr></table></figure>
<p>我们可以加一个done方法，这个方法并不会返回promise对象，所以在此之后并不能级联，done方法最后会把异常抛到全局，这样就可以被全局的异常处理函数捕获或者中断线程。这也是promise的一种最佳实践策略，当然这个done方法并没有被ES6实现，所以我们在不适用第三方Promise开源库的情况下就只能自己来实现了。为什么需要这个done方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> asyncFun = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      resolve(value);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">asyncFun(<span class="number">1</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'then resolve回调出错啦'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><code>(node:6312) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: then resolve回调出错啦</code><br><code>(node:6312) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code</code><br>我们可以看到JavaScript线程只是报了一个警告，并没有中止线程，如果是一个严重错误如果不及时中止线程，可能会造成损失。</p>
<h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>promise有一个局限就是不能够中止promise链，例如当promise链中某一个环节出现错误之后，已经没有了继续往下执行的必要性，但是promise并没有提供原生的取消的方式，我们可以看到即使在前面已经抛出异常，但是promise链并不会停止。虽然我们可以利用返回一个处于pending状态的promise来中止promise链。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        resolve(<span class="string">'hello'</span>);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错啦!'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;, error=&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'DJL箫氏'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="特殊场景"><a href="#特殊场景" class="headerlink" title="特殊场景"></a>特殊场景</h3><ul>
<li>当我们的一个任务依赖于多个异步任务，那么我们可以使用Promise.all</li>
<li>当我们的任务依赖于多个异步任务中的任意一个，至于是谁无所谓，Promise.race</li>
</ul>
<p>上面所说的都是ES6的promise实现，实际上功能是比较少，而且还有一些不足的，所以还有很多开源promise的实现库，像q.js等等，它们提供了更多的语法糖，也有了更多的适应场景。</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> defer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pending = [], value;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">resolve</span>: <span class="function"><span class="keyword">function</span> (<span class="params">_value</span>) </span>&#123;</div><div class="line">            value = _value;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                <span class="keyword">var</span> callback = pending[i];</div><div class="line">                callback(value);</div><div class="line">            &#125;</div><div class="line">            pending = <span class="literal">undefined</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">then</span>: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (pending) &#123;</div><div class="line">                pending.push(callback);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                callback(value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当调用then的时候，把所有的回调函数存在一个队列中，当调用resolve方法后，依次将队列中的回调函数取出来执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ref = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">"function"</span>)</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">then</span>: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这一段代码实现的级联的功能，采用了递归。如果传递的是一个promise那么就会直接返回这个promise，但是如果传递的是一个值，那么会将这个值包装成一个promise。</p>
<h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</div><div class="line">    <span class="comment">// console.log(y);  // 猜猜会打印出什么值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> g = gen(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'first'</span>, g.next());  <span class="comment">//first &#123; value: 3, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'second'</span>, g.next()); <span class="comment">// second &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>
<p>通俗的理解一下就是yield关键字会交出函数的执行权，next方法会交回执行权，yield会把generator中yield后面的执行结果，带到函数外面，而next方法会把外面的数据返回给generator中yield左边的变量。这样就实现了数据的双向流动。</p>
<h3 id="generator实现异步编程"><a href="#generator实现异步编程" class="headerlink" title="generator实现异步编程"></a>generator实现异步编程</h3><p>我们来看generator如何是如何来实现一个异步编程（*）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> file = <span class="keyword">yield</span> fs.readFile;</div><div class="line">        <span class="built_in">console</span>.log(file.toString());</div><div class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'捕获到异常'</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 执行器</span></div><div class="line"><span class="keyword">const</span> g = gen();</div><div class="line"></div><div class="line">g.next().value(<span class="string">'./config1.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, value</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (error) &#123;</div><div class="line">    g.throw(<span class="string">'文件不存在'</span>);</div><div class="line">  &#125;</div><div class="line">  g.next(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>那么我们next中的参数就会是上一个yield函数的返回结果，可以看到在generator函数中的代码感觉是同步的，但是要想执行这个看似同步的代码，过程却很复杂，也就是流程管理很复杂。那么我们可以借用TJ大神写的co。</p>
<h3 id="generator-配合-co"><a href="#generator-配合-co" class="headerlink" title="generator 配合 co"></a>generator 配合 co</h3><p>下面来看看如何使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"><span class="keyword">const</span> readFile = utils.promisify(fs.readFile);</div><div class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> file = <span class="keyword">yield</span> readFile(<span class="string">'./basic.use1.js'</span>);</div><div class="line">        <span class="built_in">console</span>.log(file.toString());</div><div class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'出错啦'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">co(gen());</div></pre></td></tr></table></figure></p>
<p>我们看到使用co这个执行器配合generator和promise会非常方便，非常类似同步写法，而且异步中的错误也能很容易被try catch到。这里之所以要使用utils.promisify这个工具函数将普通的异步函数转换成一个promise，是因为co may only yield a chunk, promise, generator, array, or object。使用co 配合generator最大的一个好处就是错误可以try catch 到。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>先来看一段async/await的异步写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"><span class="keyword">const</span> readFile = utils.promisify(fs.readFile);</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readJsonFile</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> file = <span class="keyword">await</span> readFile(<span class="string">'../generator/config.json'</span>);</div><div class="line">        <span class="built_in">console</span>.log(file.toString());</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'出错啦'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">readJsonFile();</div></pre></td></tr></table></figure></p>
<p>我们可以看到async/await的写法十分类似于generator，实际上async/await就是generator的一个语法糖，只不过内置了一个执行器。并且当在执行过程中出现异常，就会停止继续执行。当然await后面必须接一个promise，而且node版本必须要<code>&gt;=7.6.0</code>才可以使用，当然低版本也可以采用babel。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在开发过程中我们常常手头会同时有几个项目，那么node的版本要求很有可能是不同的，那么我们就需要安装不同版本的node，并且管理这些不同的版本，这里推荐使用<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">nvm</a>，<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="external">下载</a>好nvm，安装，使用nvm list 查看node版本列表。使用nvm use 版本号 进行版本切换。</p>
<p>在Node.js中捕获漏网之鱼<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'uncaughtException'</span>, (error: any) =&gt; &#123;</div><div class="line">    logger.error(<span class="string">'uncaughtException'</span>, error)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在浏览器环境中捕获漏网之鱼<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'onrejectionhandled'</span>, (event: any) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'onrejectionhandled'</span>, event)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">Promise中文迷你书</a><br><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="external">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a><br><a href="http://acgtofe.com/posts/2015/03/promise-from-zero" target="_blank" rel="external">深入理解Promise实现细节</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[响应式布局]]></title>
      <url>http://djl.pub/2017/09/11/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p>由于最近想开发一款响应式系统，之前对于响应式都只是略有了解，没有怎么归纳整理，现在来做一个总结。<br><a id="more"></a></p>
<h2 id="media媒体查询"><a href="#media媒体查询" class="headerlink" title="@media媒体查询"></a>@media媒体查询</h2><p>响应式布局一定离不开媒体查询。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">media mediatype and|not|only (media feature) &#123;</div><div class="line">    CSS-Code;</div><div class="line">&#125;</div><div class="line">@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>在这里mediatype一般是<code>screen</code>，在这里media feature一般是<code>max-width</code>、<code>min-width</code>定义的是可见区域。你也可以针对不同的媒体使用不同 stylesheets :<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"mediatype and|not|only (media feature)"</span> <span class="attr">href</span>=<span class="string">"mystylesheet.css"</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>当然在手机端我们一般是会禁止缩放的</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span></div></pre></td></tr></table></figure>
<h2 id="bootstrap-栅格系统实现"><a href="#bootstrap-栅格系统实现" class="headerlink" title="bootstrap 栅格系统实现"></a>bootstrap 栅格系统实现</h2><p><a href="http://v3.bootcss.com/css/#grid" target="_blank" rel="external">http://v3.bootcss.com/css/#grid</a></p>
<p>这个开发工具是基于bootstrap的<a href="http://www.layoutit.com" target="_blank" rel="external">http://www.layoutit.com</a>的布局工具</p>
<p>bootstrap中是使用float来进行布局，然后通过伪元素来进行浮动清除<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> (min-width: <span class="number">992px</span>)</div><div class="line">.col-md-<span class="number">4</span> &#123;</div><div class="line">    <span class="selector-tag">width</span>: 33<span class="selector-class">.33333333</span>%;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">media</span> (min-width: <span class="number">992px</span>)</div><div class="line">.col-md-<span class="number">1</span>, .col-md-<span class="number">10</span>, .col-md-<span class="number">11</span>, .col-md-<span class="number">12</span>, .col-md-<span class="number">2</span>, .col-md-<span class="number">3</span>, .col-md-<span class="number">4</span>, .col-md-<span class="number">5</span>, .col-md-<span class="number">6</span>, .col-md-<span class="number">7</span>, .col-md-<span class="number">8</span>, .col-md-<span class="number">9</span> &#123;</div><div class="line">    <span class="selector-tag">float</span>: <span class="selector-tag">left</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.row</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.row</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">    <span class="attribute">display</span>: table;</div><div class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="主流屏幕尺寸定义"><a href="#主流屏幕尺寸定义" class="headerlink" title="主流屏幕尺寸定义"></a>主流屏幕尺寸定义</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 超小屏幕（手机，小于 768px） */</span></div><div class="line"><span class="comment">/* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） */</span></div><div class="line"></div><div class="line"><span class="comment">/* 小屏幕（平板，大于等于 768px） */</span></div><div class="line">@<span class="keyword">media</span> (min-width: @screen-sm-min) &#123; ... &#125;</div><div class="line"></div><div class="line"><span class="comment">/* 中等屏幕（桌面显示器，大于等于 992px） */</span></div><div class="line">@<span class="keyword">media</span> (min-width: @screen-md-min) &#123; ... &#125;</div><div class="line"></div><div class="line"><span class="comment">/* 大屏幕（大桌面显示器，大于等于 1200px） */</span></div><div class="line">@<span class="keyword">media</span> (min-width: @screen-lg-min) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">max-width</span>: <span class="number">100%</span>; &#125;</div></pre></td></tr></table></figure>
<p>当然还有一种比较巧妙的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;image.jpg&quot; data-src-600px=&quot;image-600px.jpg&quot; data-src-800px=&quot;image-800px.jpg&quot; alt=&quot;&quot;&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> (min-device-width:<span class="number">600px</span>) &#123;</div><div class="line">    <span class="selector-tag">img</span><span class="selector-attr">[data-src-600px]</span> &#123;</div><div class="line">        <span class="attribute">content</span>: <span class="built_in">attr</span>(data-src-600px, url);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@<span class="keyword">media</span> (min-device-width:<span class="number">800px</span>) &#123;</div><div class="line">    <span class="selector-tag">img</span><span class="selector-attr">[data-src-800px]</span> &#123;</div><div class="line">        <span class="attribute">content</span>: <span class="built_in">attr</span>(data-src-800px, url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是会根据不同尺寸，加载不同的图片资源，这个方法非常巧妙。<code>data-*</code>允许我们可以在HTML元素中存储一些数据。而且我们可以很方便的通过<code>el.dataset</code>来进行存取删除等等。</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>另一个比较重要的就是字体的运用，<code>em</code>是根据父元素的<code>font-size</code>来进行计算，<code>rem</code>是根据根元素<code>html</code>的<code>font-size</code>来进行计算。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> (min-width: <span class="number">640px</span>) &#123; <span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>:<span class="number">1rem</span>;&#125; &#125;</div><div class="line">@<span class="keyword">media</span> (min-width:<span class="number">960px</span>) &#123; <span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>:<span class="number">1.2rem</span>;&#125; &#125;</div><div class="line">@<span class="keyword">media</span> (min-width:<span class="number">1100px</span>) &#123; <span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>:<span class="number">1.5rem</span>;&#125; &#125;</div></pre></td></tr></table></figure>
<h2 id="移动端1px效果"><a href="#移动端1px效果" class="headerlink" title="移动端1px效果"></a>移动端1px效果</h2><p>css中的1px并不总是等于物理像素1px。<br>在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。例如在devicePixelRatio为2的设备中，我们设置1px，实际上是有两个物理像素的，关于移动端的1px解决办法，可以参考这篇文章。<br><a href="http://www.cnblogs.com/lunarorbitx/p/5287309.html" target="_blank" rel="external">http://www.cnblogs.com/lunarorbitx/p/5287309.html</a><br><a href="http://blog.csdn.net/yuhk231/article/details/53976295" target="_blank" rel="external">http://blog.csdn.net/yuhk231/article/details/53976295</a></p>
<p>调试技巧：我们可以通过<a href="https://cli.im/" target="_blank" rel="external">]草料二维码生成器</a>生成二维码。然后手机扫码，就可以在手机上看到电脑上的页面。当然手机和电脑必须要在同一局域网。而且要用IP访问，也就是将localhost换成你的电脑IP地址。由于我使用的是webpack构建的项目，需要进行如下配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server -d --hot --inline --colors --progress --env.dev --public --host 0.0.0.0"</span>,</div></pre></td></tr></table></figure></p>
<p>然后在<code>webpack-dev-server</code>中配置<code>disableHostCheck: true</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">devServer: &#123;</div><div class="line">    <span class="comment">// 配置监听端口</span></div><div class="line">    port: <span class="number">8080</span>,</div><div class="line">    <span class="attr">disableHostCheck</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/lhb25/archive/2013/03/06/making-a-website-responsive-in-3-easy-steps.html" target="_blank" rel="external">http://www.cnblogs.com/lhb25/archive/2013/03/06/making-a-website-responsive-in-3-easy-steps.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Angular4学习之视图节点和内容节点]]></title>
      <url>http://djl.pub/2017/08/21/Angular%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E8%8A%82%E7%82%B9%E5%92%8C%E5%86%85%E5%AE%B9%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>通常我们在自定义一个组件后，我们会按照如下方式使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;my-component&gt;&lt;/my-component&gt;</div></pre></td></tr></table></figure>
<p>但是有时候我们组件或许有些差异，我们可以通过输入变量来控制组件的DOM结构，但是这种方式不够灵活，你可能需要列举出组件的所有差异化的表现，从而会有很多的配置选项，我们需要一种更加灵活的实现方式，那就是<code>ng-content</code>。你需要什么特定的结构，你自己决定，而不是我们写好各种组合，由你来选择。这个有点类似插件。<br><a id="more"></a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hello world</div><div class="line">&lt;ng-content&gt;&lt;/ng-content&gt;</div><div class="line">hello djlxs</div></pre></td></tr></table></figure>
<p>父组件中引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;my-component&gt;</div><div class="line">hello hello hello</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<p>那么就会用我们在<code>my-component</code>中的html代码替换掉<code>ng-content</code>,但是有时候我们可能会有多处例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;ng-content selector=&quot;app-panel-title&quot;&gt;&lt;/ng-content&gt;</div><div class="line">  &lt;ng-content selector=&quot;app-panel-content&quot;&gt;&lt;/ng-content&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>那么我们此时就需要使用selector来进行标识：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line"> &lt;app-panel&gt;</div><div class="line">   &lt;app-panel-title&gt;&lt;/app-panel-title&gt;</div><div class="line">   this is boundary</div><div class="line">   &lt;app-panel-content&gt;&lt;/app-panel-content&gt;</div><div class="line"> &lt;/app-panel&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>seletor对应的值会匹配同名的标签。这样看来使用是非常简单的。</p>
<h2 id="ViewChild-和-ContentChild"><a href="#ViewChild-和-ContentChild" class="headerlink" title="ViewChild 和 ContentChild"></a>ViewChild 和 ContentChild</h2><p>在使用这两个装饰器的时候我们首先需要明白两个概念：视图子节点和内容子节点。</p>
<ul>
<li><p>视图子节点：组件模板里面用到的子标签 (如下面的h1和<code>my-component</code>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">component(&#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">`</span></div><div class="line">        &lt;h1&gt;Hello world&lt;/h1&gt;</div><div class="line">        &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">    `</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>内容子节点：内嵌在组件标签里面的子标签(如下面的<code>my-title</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;my-component&gt;</div><div class="line">    &lt;my-title&gt;&lt;/my-title&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>好了明白了这两个概念我们就可以使用<code>ViewChild</code>和<code>ContentChild</code>这两个选择器了，<code>ViewChild</code>获取视图子节点，<code>ContentChild</code>获取内容子节点<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@ViewChild(PanelComponent) panel:PanelComponent</div><div class="line">ngAfterViewInit(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngAfterViewInit'</span>, <span class="keyword">this</span>.panel)	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@ContentChild(PanelTitleComponent) panelTitle:PanelTitleComponent</div><div class="line">ngAfterContentInit(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngAfterViewInit'</span>,<span class="string">'panelTitle'</span>, <span class="keyword">this</span>.panel)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然有时候我们可能想获取普通的H5标签，Angular为我们提供了一种简便的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;h1 #test&gt;&lt;/h1&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComponent</span>() </span>&#123;</div><div class="line">    @ViewChild(<span class="string">'test'</span>) h1Dom</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们就可以取到非自定义的标签元素了，当然这种方法可以用到自定义的标签上面。同样还有两个于此类似的装饰器<code>ViewChildren</code>和<code>ContentChildren</code>只不过会取得多个子节点。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>关于生命周期，参见另一篇博客<a href="http://djl.pub/2017/08/17/Angular4%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Angular4学习之生命周期</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Angular4学习之生命周期]]></title>
      <url>http://djl.pub/2017/08/17/Angular4%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>组件生命周期就是组件从创建到销毁过程中的一些关键点，Angular为我们提供了一些钩子函数，允许我们在组件的相应生命周期到来时进行必要操作。首先我们来看看Angular的生命周期示意图：<br><a id="more"></a><br><img src="http://ok3x4ia9b.bkt.clouddn.com/17-8-5/94857391.jpg" alt="Angular生命周期示意图"></p>
<p>从上图我们可以发现组件在构建过程中最先执行的是<code>constructor</code>构造函数，但是在构造函数中我们不应该来进行一些比较复杂的初始化操作（一般进行变量初始化操作）。下面我们来一一解释一下每个钩子函数所代表的意义和作用。</p>
<ul>
<li><p>ngOnChanges: 该方法在ngOnInit方法之前调用，或者由@input装饰器装饰的输入数据变化时调用。但是注意如果这里输入数据是一个引用类型，那么它检测的是这个对象的引用。也就是说你改变对象的某一个属性值并不会触发这个钩子函数的执行，同样你调用数组的splice等等方法也是不会改变数组的引用（这里和Vue有所不同），至于如何达到我们所想的结果，我们下面说。ngOnChanges(changes)会有一个参数格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">changeData1</span>: &#123;</div><div class="line">		<span class="attr">currentValue</span>: XXX,</div><div class="line">		<span class="attr">firstChange</span>: <span class="literal">false</span>/<span class="literal">true</span>,</div><div class="line">		<span class="attr">previousValue</span>: XXX</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">changeData2</span>: &#123;</div><div class="line">		<span class="attr">currentValue</span>: XXX,</div><div class="line">		<span class="attr">firstChange</span>: <span class="literal">false</span>/<span class="literal">true</span>,</div><div class="line">		<span class="attr">previousValue</span>: XXX</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ngOnInit:  用于数据绑定输入属性之后初始化组件。在第一次ngOnChanges调用之后调用，一般在这里进行一些组件较复杂的初始化操作。</p>
</li>
<li><p>ngDoCheck: 在每次变化监测之后调用。在一个变化监测周期内，不论数据是否变化都会执行。也就是说Angular监测的并不是数据的变动，而是可能引起数据发送变化的行为（例如：用户的各种操作，ajax请求，定时器等等）。相比ngOnChanges而言，ngDoCheck监测粒度更加小，所以在前面讲到的对象单个属性值变化时不会触发ngOnChanges钩子执行，那么我们可以通过ngDoCheck来进行监听，因为数据的变动一定会伴随相应的行为（且都是一些异步操作），但是我们也要注意像mousemove这些事件可能会频发触发调用ngDoCheck。而且在一个组件中我们一般不会同时实现ngOnchanges和ngDoCheck这两个接口。</p>
</li>
<li><p>ngAfterContentInit: 在组件中使用<code>&lt;ng-content&gt;</code>将外部内容嵌入到组件视图后调用，它在第一次ngDoCheck执行后调用，且只调用一次。</p>
</li>
<li>ngAfterContentChecked: 在组件使用<code>&lt;ng-content&gt;</code>引入外部元素的情况下，Angular在这些外部内容嵌入到组件视图之后调用，或者每次变化监测时候调用。</li>
<li>ngAfterViewInit: 当Angular创建了视图及其子视图之后调用</li>
<li>ngAfterViewChecked: 在创建了组件视图及其子视图之后被调用一次，并且在每次子组件变化监测时会被调用</li>
<li>ngOnDestroy: 在销毁指令/组件之前调用，用来销毁一些不会被垃圾回收器回收的资源（已订阅的观察者事件、绑定的DOM事件，定时器等等）。</li>
</ul>
<p>在前面说到通过@input绑定的输入值如果是一个对象，那么单纯的改变对象的某个属性值是不会触发ngOnChanges钩子函数的，那么解决办法有如下几种：</p>
<ul>
<li>实现ngDoCheck钩子函数 </li>
<li>可以改变对象的引用例如： <code>object = Object.assign({}, object)</code>、<code>arr = [].concat(arr)</code></li>
<li>使用Immutable对象来传值 （具体使用看下面的示例代码）</li>
</ul>
<p>在通常情况我们单纯改变对象的某个属性值或者对象结构，对象的引用是不会改变的，但是Immutable能够保证只要当对象的值或者结构改变时，对象的引用必定发生改变。</p>
<p>下面我们通过一段示例代码来验证一下Angular的生命周期钩子函数的运行情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--child.html---&gt;</div><div class="line">&lt;ng-container&gt;</div><div class="line">  &lt;h1&gt;lifecircle test&lt;/h1&gt;</div><div class="line">  &lt;h3&gt;姓名：&#123;&#123;obj.get(&apos;name&apos;)&#125;&#125;&lt;/h3&gt;</div><div class="line">  &lt;h3&gt;年龄：&#123;&#123;obj.age&#125;&#125;&lt;/h3&gt;</div><div class="line">  &lt;ng-content&gt;&lt;/ng-content&gt;</div><div class="line">&lt;/ng-container&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// child.component.ts</span></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  Component, OnInit, OnChanges, DoCheck, AfterViewInit, AfterViewChecked, AfterContentInit,</div><div class="line">  AfterContentChecked, OnDestroy, SimpleChanges, Input</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"></div><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">selector</span>: <span class="string">'app-lifecircle'</span>,</div><div class="line">  <span class="attr">templateUrl</span>: <span class="string">'./lifecircle.component.html'</span>,</div><div class="line">  <span class="attr">styleUrls</span>: [<span class="string">'./lifecircle.component.scss'</span>]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecircleComponent</span> <span class="title">implements</span> <span class="title">OnChanges</span>,<span class="title">OnInit</span>, <span class="title">DoCheck</span>, <span class="title">AfterContentInit</span>, <span class="title">AfterContentChecked</span> ,<span class="title">AfterViewInit</span>, <span class="title">AfterViewChecked</span>, <span class="title">OnDestroy</span> </span>&#123;</div><div class="line">  @Input() obj;</div><div class="line">  <span class="keyword">constructor</span>() &#123; &#125;</div><div class="line"></div><div class="line">  ngOnChanges(changes: SimpleChanges): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngOnChanges'</span>, changes)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngOnInit'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ngDoCheck(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngDoCheck'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ngAfterContentInit(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngAfterContentInit'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ngAfterContentChecked(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngAfterContentChecked'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ngAfterViewInit(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngAfterViewInit'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ngAfterViewChecked(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngAfterViewChecked'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ngOnDestroy(): <span class="keyword">void</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ngOnDestroy'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!--parent.html--&gt;</div><div class="line">&lt;ng-container&gt;</div><div class="line">  &lt;h1&gt;生命周期示例&lt;/h1&gt;</div><div class="line">  &lt;app-lifecircle [obj]=&quot;obj&quot;&gt;</div><div class="line">    &lt;h4&gt;这是插入的内容&lt;/h4&gt;</div><div class="line">  &lt;/app-lifecircle&gt;</div><div class="line"></div><div class="line">  &lt;button pButton type=&quot;button&quot; (click)=&quot;changeObj()&quot; label=&quot;ngAfterViewChecked&quot;&gt;&lt;/button&gt;</div><div class="line">&lt;/ng-container&gt;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// parent.component.ts</span></div><div class="line"><span class="keyword">import</span> &#123;<span class="built_in">Map</span>&#125; <span class="keyword">from</span> <span class="string">'immutable'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"></div><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">selector</span>: <span class="string">'app-blog'</span>,</div><div class="line">  <span class="attr">templateUrl</span>: <span class="string">'./blog.component.html'</span>,</div><div class="line">  <span class="attr">styleUrls</span>: [<span class="string">'./blog.component.scss'</span>]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BlogComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</div><div class="line">   obj</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123; &#125;</div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.obj = <span class="built_in">Map</span>(&#123;<span class="attr">name</span>: <span class="string">'djlxs'</span>, <span class="attr">habits</span>: &#123;<span class="attr">item</span>: <span class="string">'羽毛球'</span>&#125;&#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  changeObj() &#123;</div><div class="line">    <span class="keyword">this</span>.obj = <span class="keyword">this</span>.obj.set(<span class="string">'name'</span>, <span class="string">'djl'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webpack2实战]]></title>
      <url>http://djl.pub/2017/07/26/webpack2%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>一直对于webpack有一种莫名奇妙的恐惧感，一直在听说，从未有深入，这篇专门用来记录webpack实战笔记，<br>最终将写一个自己的脚手架工具。<br><a id="more"></a><br>在这里主要记录如何从0利用webpack构建一个项目。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir webpack-demo &amp;&amp; cd webpack-demo</div><div class="line">npm init -y</div><div class="line">npm install --save-dev webpack</div></pre></td></tr></table></figure>
<p>安装好webpack之后，我们要新建一个webpack.config.js，webpack编译项目依赖这个配置文件。我们可以利用如下命令来编译一个js文件<code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code>，但是这里要写太长，所以我们可以在<code>package.json</code>文件里面配置一个script选项：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置好后我们就可以在终端直接利用<code>npm run build</code>命令启动webpack，但是在这里webpack并不知道我们应该从哪个文件开始编译（即入口文件），也不知道编译后的文件应该存放在哪里，所以我们要在<code>webpack.config.js</code>中进行配置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./src/index.js'</span>,   <span class="comment">// 入口文件地址</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span>,   <span class="comment">// 编译输出后的文件名</span></div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)  <span class="comment">// 编译后的文件存放路径</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>配置完成后就可以<code>npm run build</code>了。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>webpack使用中对重要的就是如何使用各种loader来完成不同的任务，下面记录比较常见的loader使用。</p>
<h3 id="Loading-CSS"><a href="#Loading-CSS" class="headerlink" title="Loading CSS"></a>Loading CSS</h3><p>webpack会把css、图片等等文件编译成js文件，这样我们就可以在js文件中<code>import</code>对应的CSS或者图片文件。为了实现这个功能webpack就必须利用各种loader来将非js文件编译成js文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">entry</span>: <span class="string">'./src/index.js'</span>,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">      <span class="attr">filename</span>: <span class="string">'bundle.js'</span>,</div><div class="line">      <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">         <span class="attr">rules</span>: [</div><div class="line">           &#123;</div><div class="line">             <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  <span class="comment">// 匹配以.css结尾的文件</span></div><div class="line">             use: [</div><div class="line">               <span class="string">'style-loader'</span>, </div><div class="line">               <span class="string">'css-loader'</span></div><div class="line">             ]</div><div class="line">           &#125;</div><div class="line">         ]</div><div class="line">       &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p>
<p>我们必须要在module属性中配置各种加载器规则，<code>test</code>属性匹配文件规则，<code>use</code>指定当匹配到对应的文件时，应该使用什么加载器来处理，这里用到了<code>style-loader</code>和<code>css-loader</code>。所以我们必须为项目安装这两个加载器：<br><code>npm install --save-dev style-loader css-loader</code></p>
<blockquote>
<p><code>--save-dev</code> 表示会把依赖写入到<code>package.json</code>的<code>devDependencies</code>字段中，这样的npm 包只会在开发中使用，生产环境中不需要，<br><code>--save</code>则会把依赖写入到<code>package.json</code>的<code>dependencies</code>字段中，这里面的包在生产环境也是需要的例如：jQuery、lodash等等，当然有时候我们直接<code>npm isntall 包名</code>，这样依赖就不会写入<code>package.json</code>中，所以这样别人安装你的项目可能会报错，原因就是找不到相应的包。</p>
</blockquote>
<p><strong>这里有两个加载器，loader的处理顺序是从最后一个到第一个</strong></p>
<h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><p><code>npm install sass-loader node-sass webpack --save-dev</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">rules: [&#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,</div><div class="line">    <span class="attr">use</span>: [&#123;</div><div class="line">        <span class="attr">loader</span>: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">loader</span>: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">loader</span>: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></div><div class="line">    &#125;]</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>然后在js文件中require这个scss文件（支持ES6的话可以使用import），但是这样有一个不好的地方在于最终编译解析的的CSS文件你是看不到的，它是存在于你引入的js文件之中，一般情况下我们希望CSS文件能够单独在一个文件夹里面。所以这里我们就要使用另外一个插件<code>extract-text-webpack-plugin</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev extract-text-webpack-plugin</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> extractSass = <span class="keyword">new</span> ExtractTextPlugin(&#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">"[name].[contenthash].css"</span>,</div><div class="line">    <span class="comment">// disable: process.env.NODE_ENV === "development"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    ...</div><div class="line">    module: &#123;</div><div class="line">        <span class="attr">rules</span>: [&#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,</div><div class="line">            <span class="attr">use</span>: extractSass.extract(&#123;</div><div class="line">                <span class="attr">use</span>: [&#123;</div><div class="line">                    <span class="attr">loader</span>: <span class="string">"css-loader"</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">loader</span>: <span class="string">"sass-loader"</span></div><div class="line">                &#125;],</div><div class="line">                <span class="comment">// 在开发环境使用 style-loader</span></div><div class="line">                fallback: <span class="string">"style-loader"</span></div><div class="line">            &#125;)</div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">        extractSass</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Babel-ES6"><a href="#Babel-ES6" class="headerlink" title="Babel ES6"></a>Babel ES6</h3><p>ES6虽然在Node服务器端得到了较好的支持，但是在客户端中支持还不够多，为了使用ES6甚至是ES7，我们需要安装babel转码工具：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-core babel-preset-env babel-loader --save-dev</div></pre></td></tr></table></figure></p>
<p>其中<code>babel-core</code>是核心的转码包，但是有些ES6的语法也是不能够转换的，所以我们要使用一些其他的扩展包，例如：<code>babel-preset-env</code>和<code>babel-preset-es2015</code>。<code>babel-preset-env</code>可以将ES2015/ES2016/ES2017都转换成ES5，当然如果我们只需要将ES6转换成ES5，那么我们也可以只安装<code>babel-preset-es2015</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">    <span class="comment">// 排除node_modules目录下的文件, npm安装的包不需要编译</span></div><div class="line">    exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">    <span class="attr">use</span>: [<span class="string">'babel-loader'</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后新建一个<code>.babelrc</code>写入：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"presets"</span>: [ <span class="string">"es2015"</span> ] &#125;</div><div class="line"><span class="comment">// 或者 &#123; "presets": [ "env" ] &#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h3><p>1 安装typescript编译器和加载器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev typescript ts-loader</div></pre></td></tr></table></figure></p>
<p>2 增加tsconfig.json配置文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"compilerOptions"</span>: &#123;</div><div class="line">    <span class="string">"outDir"</span>: <span class="string">"./dist/"</span>,</div><div class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,</div><div class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,</div><div class="line">    <span class="string">"jsx"</span>: <span class="string">"react"</span>,</div><div class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="external">更多tsconfig配置 </a><br><a href="https://github.com/hstarorg/HstarDoc/blob/master/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/TypeScript%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6tsconfig%E7%AE%80%E6%9E%90.md" target="_blank" rel="external">中文配置说明</a></p>
<p>3 配置webpack.config.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">    <span class="attr">extensions</span>: [<span class="string">".tsx"</span>, <span class="string">".ts"</span>, <span class="string">".js"</span>]</div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: [</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="attr">loader</span>: <span class="string">'ts-loader'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Loading-Images"><a href="#Loading-Images" class="headerlink" title="Loading Images"></a>Loading Images</h3><p>在module属性中配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">test</span>: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</div><div class="line">   <span class="attr">use</span>: [</div><div class="line">    <span class="string">'file-loader'</span></div><div class="line">   ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然可以将图片编译成base64格式，这里我们要利用<code>url-loader</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use: [</div><div class="line">   &#123;</div><div class="line">     <span class="attr">loader</span>: <span class="string">'url-loader'</span>,</div><div class="line">     <span class="attr">options</span>: &#123;</div><div class="line">       <span class="attr">limit</span>: <span class="number">10000</span></div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>使用url-loader, 它接受一个limit参数, 单位为字节(byte)，当文件体积小于limit时, url-loader把文件转为Data URI的格式内联到引用的地方，当文件大于limit时, url-loader会调用file-loader, 把文件储存到输出目录, 并把引用的文件路径改写成输出后的路径。（为了达到这种效果只需要配置url-loader即可）</p>
<blockquote>
<p>当我们在使用url-loader将html文件中的图片转换成base64的格式，我们一定要先加上<a href="https://doc.webpack-china.org/loaders/html-loader/" target="_blank" rel="external">html-loader</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">test</span>: <span class="regexp">/\.(html)$/</span>,</div><div class="line">  <span class="attr">use</span>: &#123;</div><div class="line">    <span class="attr">loader</span>: <span class="string">'html-loader'</span>,</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">      <span class="attr">attrs</span>: [<span class="string">'img:src'</span>]  <span class="comment">// 一般在使用默认值就行attrs: ['img:src']</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p><a href="http://tutuxxx.github.io/2016/08/14/%E5%9C%A8Vue+Babel+Webpack%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8ESLint/" target="_blank" rel="external">在Vue+Babel+Webpack环境中使用ESLint</a><br><a href="http://www.jianshu.com/p/4be321cbdc1e" target="_blank" rel="external">webpack2教程续之eslint检测</a><br><a href="https://segmentfault.com/a/1190000008575829" target="_blank" rel="external">webpack2集成eslint</a></p>
<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>我们项目一般需要启动一个静态服务器，并且希望修改文件后，就能够自动完成webpack编译、实时刷新浏览器等等操作，那么这里我们需要引入<code>webpack-dev-server</code>这个模块。<code>npm install webpack-dev-server --save-dev</code>。然后在<code>webpack.config.js</code>中配置<code>devServer</code>选项：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">devServer: &#123;</div><div class="line">  <span class="comment">// 配置监听端口</span></div><div class="line">  port: <span class="number">8100</span>,</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line">   historyApiFallback用来配置页面的重定向</div><div class="line">   配置为true, 当访问的文件不存在时, 返回根目录下的index.html文件</div><div class="line">   */</div><div class="line">  historyApiFallback: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在<code>package.json</code>的<code>script</code>中增加一个任务：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server -d --hot --colors --inline --env.dev"</span></div></pre></td></tr></table></figure></p>
<p>然后执行<code>npm run dev</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">--progress这个参数是显示进度</div><div class="line">--colors 显示颜色，这样命令窗口看起来比较爽</div><div class="line">--hot  开启热替换</div><div class="line">--inline 监听文件变化，浏览器自动刷新，类似于liveonload这个功能</div><div class="line">--d 开启debug模式，这样在浏览器中我们就可以看到源码</div></pre></td></tr></table></figure></p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>我们会碰到这样一种情况就是我们打包图片的时候，每一次build之后，图片的名称都会改变，这时在html文件中是无法正确引入图片路径的，为了解决这个问题，我们需要引入<code>html-webpack-plugin</code>这个插件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install html-webpack-plugin --save-dev</div></pre></td></tr></table></figure></p>
<p>然后在<code>webpack.config.js</code>中引入<code>var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)</code>,最后在plugins属性中进行配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">        <span class="comment">/*</span></div><div class="line">         html-webpack-plugin用来打包入口html文件</div><div class="line">         */</div><div class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             template参数指定入口html文件路径, 插件会把这个文件交给webpack去编译,</div><div class="line">             webpack按照正常流程, 找到loaders中test条件匹配的loader来编译, 那么这里html-loader就是匹配的loader</div><div class="line">             html-loader编译后产生的字符串, 会由html-webpack-plugin储存为html文件到输出目录, 默认文件名为index.html</div><div class="line">             可以通过filename参数指定输出的文件名</div><div class="line">             html-webpack-plugin也可以不指定template参数, 它会使用默认的html模板.</div><div class="line">             */</div><div class="line">           template: <span class="string">'./dist/index.html'</span> <span class="comment">// 基础html模板</span></div><div class="line">        &#125;)</div><div class="line">    ],</div></pre></td></tr></table></figure></p>
<p>使用这个插件以后，会自动创建一个index.html，并且把编译后的js文件，图片资源链接都插入到对应位置。</p>
<h3 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h3><p>可以利用html-webpack-plugin的favicon配置属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">   <span class="attr">title</span>: <span class="string">'Webpack TypeScript'</span>,</div><div class="line">   <span class="attr">favicon</span>: <span class="string">'favicon.ico'</span>, <span class="comment">//icon路径</span></div><div class="line">   template: <span class="string">'./dist/index.html'</span> <span class="comment">// 基础html模板</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>具体可以查看<a href="https://github.com/jantimon/html-webpack-plugin/tree/master/examples/favicon" target="_blank" rel="external">示例</a>。当然除了这个方法我们还可以使用<code>favicons-webpack-plugin</code>这个插件</p>
<h3 id="提取公共代码（CommonsChunkPlugin）"><a href="#提取公共代码（CommonsChunkPlugin）" class="headerlink" title="提取公共代码（CommonsChunkPlugin）"></a>提取公共代码（CommonsChunkPlugin）</h3><p>有一些类库如bootstrap或者jQuery等等会被多个页面共享，最好的方式是讲这些公共的类库打包成一个通用的js文件。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    name: "common",</div><div class="line">    filename: "js/common.js",</div><div class="line">    chunks: ['index', 'detail] //index和details为入口文件名</div><div class="line">&#125;),</div></pre></td></tr></table></figure></p>
<h3 id="代码压缩（UglifyJsPlugin）"><a href="#代码压缩（UglifyJsPlugin）" class="headerlink" title="代码压缩（UglifyJsPlugin）"></a>代码压缩（UglifyJsPlugin）</h3><p>webpack2默认开启了代码压缩，但是没有做到压缩到最小，所以我们可以通过手动配置覆盖默认配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">   <span class="comment">// 最紧凑的输出</span></div><div class="line">   beautify: <span class="literal">false</span>,</div><div class="line">   <span class="comment">// 删除所有的注释</span></div><div class="line">   comments: <span class="literal">false</span>,</div><div class="line">   <span class="attr">compress</span>: &#123;</div><div class="line">       <span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告  </span></div><div class="line">       warnings: <span class="literal">false</span>,</div><div class="line">       <span class="comment">// 删除所有的 `console` 语句</span></div><div class="line">       <span class="comment">// 还可以兼容ie浏览器</span></div><div class="line">       drop_console: <span class="literal">true</span>,</div><div class="line">       <span class="comment">// 内嵌定义了但是只用到一次的变量</span></div><div class="line">       collapse_vars: <span class="literal">true</span>,</div><div class="line">       <span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></div><div class="line">       reduce_vars: <span class="literal">true</span>,</div><div class="line">   &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">    <span class="comment">//查找module的话从这里开始查找</span></div><div class="line">    root: <span class="string">'E:/github/flux-example/src'</span>, <span class="comment">//绝对路径</span></div><div class="line"></div><div class="line">    <span class="comment">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></div><div class="line">    extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>],</div><div class="line"></div><div class="line">    <span class="comment">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></div><div class="line">    alias: &#123;</div><div class="line">        <span class="attr">AppStore</span> : <span class="string">'js/stores/AppStores.js'</span>,<span class="comment">//后续直接 require('AppStore') 即可</span></div><div class="line">        ActionType : <span class="string">'js/actions/ActionType.js'</span>,</div><div class="line">        <span class="attr">AppAction</span> : <span class="string">'js/actions/AppAction.js'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>有时我们为了防止缓存，需要给编译生成的文件名设置一个hash，配置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].[hash].bundle.js'</span>,</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="webpack-引入第三方库"><a href="#webpack-引入第三方库" class="headerlink" title="webpack 引入第三方库"></a>webpack 引入第三方库</h2><p><a href="http://djl.pub/2017/05/01/webpack%E5%BC%95%E5%85%A5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/">详情见这篇文章</a></p>
<p>即使不符合commonJs规范<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">resolve</span>: &#123;</div><div class="line">        <span class="attr">root</span>: [],</div><div class="line">        <span class="attr">alias</span>: &#123;</div><div class="line">            <span class="string">'jquery'</span>: path.resolve(rootDir, <span class="string">'./lib/jquery.min.js'</span>); </div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">        <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</div><div class="line">            <span class="attr">$</span>: <span class="string">'jquery'</span></div><div class="line">        &#125;),</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"build": "set NODE_ENV=production&amp;&amp;webpack -p --progress --colors",</div><div class="line">"dev": "set NODE_ENV=development&amp;&amp;webpack-dev-server -d --hot --colors --env.dev"</div></pre></td></tr></table></figure>
<p>然后在<code>webpack.config.js</code>中就可以通过<code>process.env.NODE_ENV</code>拿到对应的环境变量值</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/fenivana/webpack-in-action" target="_blank" rel="external">webpack 2 打包实战</a></p>
<p><a href="https://github.com/dwqs/blog/issues/46" target="_blank" rel="external">Webpack 2 快速入门</a></p>
<p><a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="external">webpack各种loader</a></p>
<p>持续更新中。。。。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[exports和module.exports的区别]]></title>
      <url>http://djl.pub/2017/07/06/exports%E5%92%8Cmodule-exports%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>之前一直比较困惑exports和module.exports有什么区别。这里做一个比较详细的解释<br><a id="more"></a></p>
<p>首先我们来看一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"></div><div class="line">b.name = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = &#123;<span class="attr">name</span>: <span class="number">3</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div></pre></td></tr></table></figure>
<p>运行 test.js 结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; name: 1 &#125;</div><div class="line">&#123; name: 1 &#125;</div><div class="line">&#123; name: 2 &#125;</div><div class="line">&#123; name: 2 &#125;</div><div class="line">&#123; name: 2 &#125;</div><div class="line">&#123; name: 3 &#125;</div></pre></td></tr></table></figure></p>
<p><strong>解释</strong> ：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。</p>
<p>明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：</p>
<ul>
<li><p><code>module.exports</code> 初始值为一个空对象 {}</p>
</li>
<li><p><code>exports</code> 是指向的 <code>module.exports</code> 的引用</p>
</li>
<li><p><code>require()</code> 返回的是 <code>module.exports</code> 而不是 <code>exports</code></p>
</li>
<li><p><code>exports.xxx</code>，相当于在导出对象上挂属性，该属性对调用模块直接可见</p>
</li>
<li><p><code>exports =</code> 相当于给exports对象重新赋值，调用模块不能访问exports对象及其属性,因为require返回的是<code>module.exports</code></p>
</li>
<li><p>如果此模块是一个类，就应该直接赋值module.exports，这样调用者就是一个类构造器，可以直接new实例；如果要导出一个模块实例，那么就直接挂在exports上</p>
</li>
<li><p>如果module.exports已经存在(即使是module.exports = {})，那么exports上面添加的任何属性都将被忽略</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="string">'ROCK IT!'</span>;</div><div class="line">exports.name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is Lemmy Kilmister'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rocker = <span class="built_in">require</span>(<span class="string">'./rocker.js'</span>);</div><div class="line">rocker.name(); <span class="comment">// TypeError: Object ROCK IT! has no method 'name'</span></div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html" target="_blank" rel="external">Node.js Module – exports vs module.exports</a></p>
<p><a href="https://github.com/chemdemo/chemdemo.github.io/issues/2" target="_blank" rel="external">Node.js module.exports与exports</a></p>
<p><a href="https://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="external">exports 和 module.exports 的区别</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue2变化]]></title>
      <url>http://djl.pub/2017/05/01/Vue2%E5%8F%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>之前学习的是Vue1.0，这次项目开发使用的Vue2.0，其中有一些不同和新功能在这里记录一下。<a href="http://cn.vuejs.org/v2/guide/migration.html" target="_blank" rel="external">迁移文档</a><br><a id="more"></a></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a><a href="https://cn.vuejs.org/v2/guide/migration.html#过滤器" target="_blank" rel="external">过滤器</a></h2><p>1 Vue2 filter只能使用在双花括号中,在v-for等等指令中已经不能使用过滤器，转而使用计算属性和第三方库方法（也可以原声js写）例如：filterBy</p>
<p>2 现在Vue2已经移除了所有内置的过滤器，替代方案是使用第三方库（当然简单的也可以自己写一个）</p>
<p>3 参数形式改变，不再是使用空格来分隔参数而是<br><code>&lt;p&gt;\{\{ date \| formatDate(&#39;YY-MM-DD&#39;, timeZone) \}\}&lt;/p&gt;</code></p>
<p>当然如果你还是习惯Vue的那种内置过滤器，这里有一个比较好的filters库<a href="https://github.com/freearhey/vue2-filters" target="_blank" rel="external">vue2-filters</a>。</p>
<h2 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h2><p>组件通信，在Vue1.0中采用的是<code>$dispatch</code>和<code>$boradcast</code>,Vue2.0弃用了，同一使用了$emit，但是并没有使得兄弟组件之间的通信变得简单，对于简单的兄弟组件间的通信，我们可以通过创建一个空的Vue实例作为中央事件总线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</div><div class="line"><span class="comment">// 触发组件 A 中的事件</span></div><div class="line">bus.$emit(<span class="string">'id-selected'</span>, <span class="number">1</span>)</div><div class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></div><div class="line">bus.$on(<span class="string">'id-selected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>对于夸层级的组件（不是父子组件而是爷孙组件）通信，$emit并不能直接像事件冒泡一样，被爷爷组件监听到，这里我们也可以建立一个空的Vue实例作为中央事件总线，来进行通信。例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将在各处使用该事件中心</span></div><div class="line"><span class="comment">// 组件通过它来通信</span></div><div class="line"><span class="keyword">var</span> eventHub = <span class="keyword">new</span> Vue()</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Son 孙子组件</span></div><div class="line"><span class="comment">// ...</span></div><div class="line">methods: &#123;</div><div class="line">  <span class="attr">addTodo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    eventHub.$emit(<span class="string">'add-todo'</span>, &#123; <span class="attr">text</span>: <span class="keyword">this</span>.newTodoText &#125;)</div><div class="line">    <span class="keyword">this</span>.newTodoText = <span class="string">''</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 爷爷组件</span></div><div class="line">created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  eventHub.$on(<span class="string">'add-todo'</span>, <span class="keyword">this</span>.addTodo)</div><div class="line">  eventHub.$on(<span class="string">'delete-todo'</span>, <span class="keyword">this</span>.deleteTodo)</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>以上主要针对于简单的组件通信，当然如果情况变得更加复杂，还是推荐使用Vuex。</p>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>1 遍历对象时的参数顺序：原来是(key, value)，现在是 (value, key)<br>2 v-for=”number in 10” 的 number 从 0 开始到 9 结束，现在从 1 开始，到 10 结束。<br>3 track-by 已经替换为 key</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>1 现在只允许单项传递（父传子），如果子组件要改变props传递过来的值，并且使得父组件相应的得到改变，就必须利用$emit触发事件。当然还有一种情况就是子组件要求更改props传递过来的值，不需要父组件随之改变，这样貌似不会有什么影响，实际开发中也是一不小心就这样做了，但是这样是反模式的，更好的方式就是在data属性中建立一个字段dataA，然后props值来初始化这个dataA</p>
<p>2v-bind 的 .once和.sync 修饰符 </p>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>只能监听自定义事件，如果要监听根元素原生事件，添加.native修饰符<br><code>&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webpack引入插件的几种方法]]></title>
      <url>http://djl.pub/2017/05/01/webpack%E5%BC%95%E5%85%A5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>通常webpack引入插件有4中方式：<br>1 安装后直接在某个模块中运用<br>2 使用webpack plugins功能加载ProvidePlugin插件<br>3 expose-loader加载器加载<br>4 包装插件<br><a id="more"></a></p>
<h2 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h2><p>在需要使用的js文件中引入：<br><code>var  $  = require(&#39;jquery&#39;)</code>或者<code>import $ form &#39;jquery&#39;</code></p>
<h2 id="使用plugins"><a href="#使用plugins" class="headerlink" title="使用plugins"></a>使用plugins</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</div><div class="line">      <span class="attr">$</span>: <span class="string">"jquery"</span>,</div><div class="line">      <span class="attr">jQuery</span>: <span class="string">"jquery"</span></div><div class="line">    &#125;)</div><div class="line">]</div></pre></td></tr></table></figure>
<p>使用这种方式，就可以全局使用jQuery，但是对于使用了ESlint就会报错：<code>&#39;$&#39; is not defined</code></p>
<blockquote>
<p>ProvidePlugin: Automatically loaded modules. Module (value) is loaded when the identifier (key) is used as free variable in a module. The identifier is filled with the exports of the loaded module.</p>
</blockquote>
<p>也就是说jQuery模块只会在使用<code>$</code>的模块中加载，并不是真正的全局加载</p>
<h2 id="expose-loader"><a href="#expose-loader" class="headerlink" title="expose-loader"></a><a href="https://github.com/webpack-contrib/expose-loader" target="_blank" rel="external">expose-loader</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">test</span>: <span class="built_in">require</span>.resolve(<span class="string">'jquery'</span>),</div><div class="line">    <span class="attr">use</span>: [&#123;</div><div class="line">        <span class="attr">loader</span>: <span class="string">'expose-loader'</span>,</div><div class="line">        <span class="attr">options</span>: <span class="string">'$'</span></div><div class="line">    &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在任意模块中引入<code>require(&quot;expose-loader?$!jquery&quot;);</code></p>
<h2 id="包装jQuery"><a href="#包装jQuery" class="headerlink" title="包装jQuery"></a>包装jQuery</h2><p>vendor.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></div><div class="line"><span class="built_in">window</span>.$ = $</div><div class="line"><span class="built_in">window</span>.jQuery = $</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> $</div></pre></td></tr></table></figure></p>
<p>模块引入：<code>import $ from &#39;../assets/vendor.js&#39;</code><br>webpakck中设置别名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alias: &#123;</div><div class="line">    <span class="comment">//将其指向vendor.js所在位置</span></div><div class="line">    jquery : <span class="string">'src/assets/jquery-vendor.js'</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://blog.csdn.net/yiifaa/article/details/51916560" target="_blank" rel="external">参考文章</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义多选框]]></title>
      <url>http://djl.pub/2017/04/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E9%80%89%E6%A1%86/</url>
      <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span> &gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"el-checkbox"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">class</span>=<span class="string">"really-checkbox"</span> &gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"checkbox-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"label-text"</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.cell</span> <span class="selector-class">.really-checkbox</span>,<span class="selector-class">.cell</span> <span class="selector-class">.label-text</span>,<span class="selector-class">.cell</span> <span class="selector-class">.checkbox-icon</span>&#123;</div><div class="line">    <span class="attribute">vertical-align</span>: middle;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.checkbox-icon</span> &#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#bfcbd9</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</div><div class="line">    <span class="attribute">box-sizing</span>: border-box;</div><div class="line">    <span class="attribute">width</span>: <span class="number">18px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">18px</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</div><div class="line">    <span class="attribute">transition</span>: border-color .<span class="number">25s</span> <span class="built_in">cubic-bezier</span>(.71,-.46,.29,1.46),background-color .<span class="number">25s</span> <span class="built_in">cubic-bezier</span>(.71,-.46,.29,1.46);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-class">.checkbox-icon</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(45deg) <span class="built_in">scaleY</span>(1);</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg) <span class="built_in">scaleY</span>(1);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-class">.checkbox-icon</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">    <span class="attribute">box-sizing</span>: content-box;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#fff</span>;</div><div class="line">    <span class="attribute">border-left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">border-top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">8px</span>;</div><div class="line">    <span class="attribute">width</span>:<span class="number">4px</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">1px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">5px</span>;</div><div class="line">    <span class="attribute">transition</span>: transform .<span class="number">15s</span> <span class="built_in">cubic-bezier</span>(.71,-.46,.88,.6) .<span class="number">05s</span>;</div><div class="line">    <span class="attribute">-ms-transform-origin</span>: center;</div><div class="line">    <span class="attribute">transform-origin</span>: center;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-class">.really-checkbox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.checkbox-icon</span>&#123;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#20a0ff</span>;</div><div class="line">    <span class="attribute">border-color</span>: <span class="number">#0190fe</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-class">.really-checkbox</span> &#123;</div><div class="line">    <span class="attribute">visibility</span>: hidden;</div><div class="line">    <span class="attribute">width</span>:<span class="number">0</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[angular1学习之控制器通信]]></title>
      <url>http://djl.pub/2017/04/07/angular1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>指令与控制器之间通信，无非是以下几种方法：</p>
<ul>
<li>基于scope继承的方式</li>
<li>基于event传播的方式</li>
<li>service的方式<a id="more"></a>
</li>
</ul>
<h1 id="基于scope继承的方式"><a href="#基于scope继承的方式" class="headerlink" title="基于scope继承的方式"></a>基于scope继承的方式</h1><p>最简单的让控制器之间进行通信的方法是通过scope的继承。假设有两个控制器Parent、Child，Child 在 Parent 内，那Child 可以称为控制器Parent的子控制器，它将继承父控制器Parent的scope。这样，Child就可以访问到Parent的scope中的所有函数和变量了。</p>
<p>需要注意的是，由于scope的继承是基于Js的原型继承，如果变量是基本类型的，那在Child中的修改（写），有可能会导致Parent中的数据变脏。如下：</p>
<p>基本类型以及引用类型变量的继承</p>
<p>此<a href="http://jsbin.com/qezot/4/edit?html,js,output" target="_blank" rel="external">DEMO</a>代码中我们看到，两个_value，其中一个 _value 属性是直接被注册到\$scope 中，另一个 _value 是注册到 parent 控制的 $scope.obj 中，DEMO效果如下：</p>
<p>1 child能读取到parent中的_value值，所以默认页面 显示的是4个 default值</p>
<p>2 如果先改变了直接注册在child上 $scope 上的 _value 属性，则直接注册在 parent.$scope 的 _value 跟直接注册在 chile.$scope的_value失去了联系，页面上的表现：就是如果先点击了child的按钮，点击parent的按钮 child.$scope 上的 _value 则不会变化。</p>
<p>3 反过来，如果未对直接注册在 chile.$scope 的_value进行改写，则注册在 parent.$scope 的 _value 跟chile.$scope 的 _value还有联系，页面上表现跟以上相反。</p>
<p>4 而注册在 obj 上的 _value 属性，则一直是有联系的。</p>
<p>经过以上实验，我们得出一下结论：</p>
<blockquote>
<p><strong>子级scope改写的属性不要直接注册在$scope对象上，而应该尽可能注册在$scope上的引用类型上，以免污染$scope。</strong></p>
</blockquote>
<h1 id="基于event传播的方式"><a href="#基于event传播的方式" class="headerlink" title="基于event传播的方式"></a>基于event传播的方式</h1><p>通过 scope 继承 能处理父子级控制器之间的通信问题，但是不能处理兄弟/相邻控制器之间的通信问题。而基于 event 传递的方式进行通信可以解决父子级的通信问题。angular提供了三个方法：$on , $emit , $broadcast</p>
<h2 id="子–-gt-父：-emit"><a href="#子–-gt-父：-emit" class="headerlink" title="子–&gt;父：$emit"></a>子–&gt;父：$emit</h2><p>event传播过程是这样的：</p>
<p>子scope中的控制器通过 $scope.$emit注册一个向上传播的事件,该事件会经过每一层的父scope，但是每一层父scope不会去处理,如果要处理就在想要处理的父scope中使用$scope.$on监听<a href="http://jsbin.com/goxiw/5/edit?html,js,output" target="_blank" rel="external">DEMO</a>。跟JS中的DOM事件一样，如果你不想让你的事件再往更上层传播，在$on中的处理函数调用e.stopPropagation()即可。</p>
<h2 id="父–-gt-子：-broadcast"><a href="#父–-gt-子：-broadcast" class="headerlink" title="父–&gt;子：$broadcast"></a>父–&gt;子：$broadcast</h2><p>从父到子，跟子集到父级一样，使用同样用$broadcast注册时间，用 $on 监听着，<a href="http://jsbin.com/gidomu/10/edit?html,js,output" target="_blank" rel="external">DEMO</a>。</p>
<h2 id="同级之间"><a href="#同级之间" class="headerlink" title="同级之间"></a>同级之间</h2><p>拥有同个父scope的子级scope之间，也就是兄弟/相邻scope之间的通信，其实是借助共同父级传递消息的：</p>
<p>子级scope中有谁想传消息了，$emit一个给“奶爸”,然后通过“奶爸”$broadcast给所有孩子这个相同的信息，当然发出信息的那个可以选择是否要忽略掉自己发出的信息</p>
<h1 id="angular服务的方式"><a href="#angular服务的方式" class="headerlink" title="angular服务的方式"></a>angular服务的方式</h1><p>在angular中服务是一个单例，在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。参照以下例子，在一个控制器修改了服务对象的值，在另一个相邻控制器中获取到修改后的值：</p>
<p><a href="http://jsbin.com/hopazo/5/edit?html,css,js,output" target="_blank" rel="external">DEMO</a></p>
<p><strong>特别注明：此文为转载，原文链接 <a href="http://www.html5jscss.com/angular-between-controller.html" target="_blank" rel="external">AngularJs开发——控制器间的通信</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[angular1学习之directive]]></title>
      <url>http://djl.pub/2017/04/06/angular1%E5%AD%A6%E4%B9%A0%E4%B9%8Bdirective/</url>
      <content type="html"><![CDATA[<p>作为只学过Vue的前端来说，angular的概念还真是比较多的，但是每接触一个概念我都会和Vue相关概念做一个对比，这样的对比对我理解angular起了非常大的作用。这节主要讲解directive，类比Vue就好比Vue里面的组件。<br><a id="more"></a></p>
<h1 id="自定义一个指令"><a href="#自定义一个指令" class="headerlink" title="自定义一个指令"></a>自定义一个指令</h1><p>首先angular定义一个指令的方式如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'container'</span>,[])</div><div class="line">app.controller(<span class="string">'wrap'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">    $scope.nickName = <span class="string">'DJL箫氏'</span></div><div class="line">&#125;)</div><div class="line">app.directive(<span class="string">'myDirective'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'A'</span>,</div><div class="line">        <span class="attr">template</span> : <span class="string">'&lt;h1&gt;自定义指令&#123;&#123;nickName&#125;&#125;&lt;/h1&gt;'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我们通过app.directive方法来创建指令，指令名称遵从驼峰命名规则，在使用的时候用<code>-</code>分开<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>作为刚学angular的人来说，为什么有时候使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'wrap'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">    $scope.nickName = <span class="string">'DJL箫氏'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>有时候<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'wrap'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">    $scope.nickName = <span class="string">'DJL箫氏'</span></div><div class="line">&#125;])</div></pre></td></tr></table></figure></p>
<p>如果服务名和function中的参数名一致，则可以不写成数组的形式，如果要更换名字则写成数组的形式。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'wrap'</span>, [<span class="string">'$scope'</span>,<span class="string">'myService'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    $scope.nickName = <span class="string">'DJL箫氏'</span></div><div class="line">&#125;])</div></pre></td></tr></table></figure></p>
<p>那么a即<code>$scope</code>服务，b即<code>myService</code>服务</p>
<h1 id="常用属性介绍"><a href="#常用属性介绍" class="headerlink" title="常用属性介绍"></a>常用属性介绍</h1><h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>自定义指令会返回一个对象，里面有很多属性<code>restrict:A</code>属性表示在html代码中调用这个属性只能通过属性的形式来调用，当然值还有E（只能通过标签元素的方式调用）,C(只能通过class的方式调用)，EAC（以上三种方式都可以）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="name">my-directive</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-directive"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="template-amp-templateUrl"><a href="#template-amp-templateUrl" class="headerlink" title="template &amp; templateUrl"></a>template &amp; templateUrl</h2><p>template属性则是这个指令的DOM结构，也就是说指令适用于与DOM有关的场景。我们可以看到在指令中可以拿到包含它的controller中的数据（$scope）。当然如果指令的DOM结构非常复杂，这个时候我们可以使用templateUrl属性来替代template属性，templateUrl的值为dom模板的地址。当然我们可以使用<code>ng-template</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/ng-template&quot; id=&quot;part.html&quot;&gt;</div><div class="line">    &lt;h1&gt;通过ng-template封装的part.html&lt;/h1&gt;</div><div class="line">    &lt;p&gt;这里是part.html中的内容&lt;/p&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">templateUrl: <span class="string">'part.html'</span></div></pre></td></tr></table></figure>
<h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>该属性表明这个指令是直接插入到DOM结构中（值为TRUE），还是先把<code>&lt;my-directive&gt;&lt;/my-directive&gt;</code>这个标签去除后只插入指令中template或者templateUrl中的内容。<br><img src="http://ok3x4ia9b.bkt.clouddn.com/17-4-6/52136146-file_1491473056558_dddc.png" alt="值为false"><br><img src="http://ok3x4ia9b.bkt.clouddn.com/17-4-6/30517686-file_1491472930303_7e1e.png" alt="值为true"></p>
<h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><p>在前面我们知道directive可以直接拿到所在controller中的数据，但是如果在同一个controller中有多个directive，我们希望通过传入directive不同的值来展示不同的结果，这时我们就要使用scope属性，这个属性类似于Vue组件中props属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-directive</span> <span class="attr">user</span>=<span class="string">"userA"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-directive</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">scope:&#123;</div><div class="line">    <span class="attr">user</span>: <span class="string">"="</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">template</span> : <span class="string">"&lt;p&gt;姓名:&#123;&#123;user.name&#125;&#125;&lt;/p&gt;&lt;p&gt;性别：&#123;&#123;user.sex&#125;&#125;&lt;/p&gt;"</span></div><div class="line"></div><div class="line">App.controller(<span class="string">"wrap"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">    $scope.userA = &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">"DJL箫氏"</span>,</div><div class="line">        <span class="attr">sex</span> : <span class="string">"男"</span></div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这里<code>user: &#39;=&#39;</code>,其中‘=’表示传入一个引用值（如果在directive中改变数据，controller中的数据也会跟随改变），当然值还可以是‘@’（传入一个字符串，那么此时传入的就是userA这个字符串了），&amp;（传入一个回调函数）</p>
<h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p>link属性就类似于Vue里面的生命周期钩子函数，是会自动执行的，所以可以把一些初始化任务放在里面。link函数有3个参数scope（暂时理解为directive中scope属性）,element（指令中template对应的DOM）,attrs。</p>
<p>由于Angular几乎照搬了jQuery的DOM操作源码，所以我们在操作DOM时，可以基本舒勇jQuery的语法，当然如果我们要使用jQuery来操作也非常简单，我们只需要安装jQuery然后在index.html中引入jQuery（注意顺序）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 保证在angular.js之前引入jquery.js --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"components/jquery/dist/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"components/angular/angular.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h2 id="transclude"><a href="#transclude" class="headerlink" title="transclude"></a>transclude</h2><p>有时候我们想在指令中添加一些自定义的元素，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-directive</span> <span class="attr">user</span>=<span class="string">"userA"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-directive</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这时我们就需要设置transclude属性值为true。<br>同时在指令的DOM结构合适的位置中加入<code>&lt;ng-transclude&gt;&lt;/ng-transclude&gt;</code>或者以属性的方式<code>&lt;div ng-transclude&gt;&lt;/div&gt;</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template : <span class="string">'&lt;h1&gt;自定义指令&lt;ng-transclude&gt;&lt;/ng-transclude&gt;&lt;/h1&gt;'</span></div></pre></td></tr></table></figure></p>
<p>所以我们会发现ng-app这些指令的transclude属性都设置成了true</p>
<p>ok 目前常用的就是这些，下节会讲directive之间的通信问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript模块加载 - AMD]]></title>
      <url>http://djl.pub/2017/04/04/JavaScript%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%20-%20AMD/</url>
      <content type="html"><![CDATA[<p>随着js代码的增加，将所有的js代码放在一个js文件里面，会使得这个js代码非常臃肿，所以我们需要把js代码模块化。于是我们会按如下方法来做：<br><a id="more"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"a.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"b.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"c.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"d.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这样做有两个缺陷：1 随着js文件的增多，加载js文件会阻塞浏览器的渲染；2 这些js文件之间可能存在严格的依赖关系，导致js文件的加载必须遵从顺序。</p>
<p>为了解决这个问题，JavaScript引入了模块的概念，目前分为浏览器端和服务器端。浏览器端模块加载规范一般有AMD（异步加载js文件）和CMD（同步加载js文件），服务器端就是common.js规范。而一般情况下，浏览器端更适合使用异步加载，因为在浏览器端，js文件的加载取决于网络状况，采用异步加载，可以避免因为网络问题带来的浏览器阻塞问题。在这里将简单介绍<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>,AMD规范的一种实现方式。</p>
<h1 id="引入require-js"><a href="#引入require-js" class="headerlink" title="引入require.js"></a>引入require.js</h1><p>首先我们在页面中引入require.js，并且设置data-main属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>其中data-main属性指定所有js文件的一个入口。为了在引入require.js的时候不阻塞浏览器的渲染，我们可以将<code>script</code>标签放在body底部，当然也可以利用script异步加载属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"js/require.js"</span> defer <span class="keyword">async</span>=<span class="string">"true"</span> &gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><code>defer</code>是为了兼容IE</p>
<h1 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h1><p>现在我们就可以在main.js入口文件中书写自己的js代码了，一般情况下入口文件会依赖很多其他模块，那么我们在使用时需要引入这些模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    alert(a.add(<span class="number">1</span>,<span class="number">2</span>))   <span class="comment">// 3</span></div><div class="line">    alert(b.dec(<span class="number">1</span>,<span class="number">2</span>))   <span class="comment">// -1</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>根据AMD规范引入模块的写法，我们在main.js这个模块中引入了a.js和b.js这两个模块。这两个模块和main.js在同一个目录之下，但是如果不在一个目录中，那么我们就需要通过require.config定义模块路径：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="string">'a'</span>: <span class="string">'test/a'</span>,</div><div class="line">        <span class="string">'b'</span>: <span class="string">'test/b'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.alert(a.add(<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">    <span class="built_in">window</span>.alert(b.dec(<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>require.config要放在main.js的头部。当然也可以改变js文件路径的基目录<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>:<span class="string">'js/lib'</span>,</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="string">'a'</span>: <span class="string">'a'</span>,</div><div class="line">        <span class="string">'b'</span>: <span class="string">'b'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.alert(a.add(<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">    <span class="built_in">window</span>.alert(b.dec(<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h1 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h1><p>根据AMD规范，我们定义模块要是<code>define</code>。例如a.js</p>
<h2 id="定义键值对"><a href="#定义键值对" class="headerlink" title="定义键值对"></a>定义键值对</h2><p>如果一个模块不依赖于其他模块并且只是一些键值对的容器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(&#123;</div><div class="line">    <span class="attr">color</span>: <span class="string">"black"</span>,</div><div class="line">    <span class="attr">size</span>: <span class="string">"unisize"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>如果一个模块不依赖于其他模块，但是又要做一些设置工作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//Do setup work here</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">color</span>: <span class="string">"black"</span>,</div><div class="line">        <span class="attr">size</span>: <span class="string">"unisize"</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="定义有依赖的函数"><a href="#定义有依赖的函数" class="headerlink" title="定义有依赖的函数"></a>定义有依赖的函数</h2><p>一般情况下，一个模块都会依赖一个或者多个其他模块，在定义这些模块时，我们要首先引入它所依赖的模块。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">"a"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">       <span class="attr">result</span> : a.add(<span class="number">1</span> + <span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="加载不符合AMD规范的模块"><a href="#加载不符合AMD规范的模块" class="headerlink" title="加载不符合AMD规范的模块"></a>加载不符合AMD规范的模块</h1><p>有一些模块是不符合AMD规范的，我们在使用的时候，要进行如下配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">　　<span class="attr">shim</span>: &#123;</div><div class="line">　　　<span class="string">'underscore'</span>:&#123;</div><div class="line">　　　　　<span class="attr">exports</span>: <span class="string">'_'</span></div><div class="line">　　　 &#125;,</div><div class="line">　　   <span class="string">'backbone'</span>: &#123;</div><div class="line">　　　　　　<span class="attr">deps</span>: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</div><div class="line">　　　　　　<span class="attr">exports</span>: <span class="string">'Backbone'</span></div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>即要在shim属性中定义这个模块导出后的变量名和依赖。</p>
<p>以上介绍的是require.js的最基本用法，当然目前也就用到了这么多。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">Javascript模块化编程（三）：require.js的用法</a><br><a href="http://requirejs.org/" target="_blank" rel="external">require.js</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node开发小工具]]></title>
      <url>http://djl.pub/2017/03/25/NODE%E5%BC%80%E5%8F%91%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>本文专门用来搜集一些平时开发中可能用到的小插件，持续更新中。。。。。。<br><a id="more"></a></p>
<ul>
<li><p><a href="https://github.com/JacksonTian/anywhere" target="_blank" rel="external">anywhere</a>   随启随用的静态文件服务器</p>
</li>
<li><p><a href="https://github.com/indexzero/http-server" target="_blank" rel="external">http-server </a> 轻量级的http-server服务器</p>
</li>
<li><p><a href="https://www.npmjs.com/package/npm-run-all" target="_blank" rel="external">npm-run-all</a>  同时运行多个不退出js程序</p>
</li>
<li><p><a href="https://www.npmjs.com/package/serve-favicon" target="_blank" rel="external">serve-favicon</a> 设置浏览器标签页图标</p>
</li>
<li><p><a href="https://www.npmjs.com/package/supervisor" target="_blank" rel="external">supervisor</a>  自动重启服务</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CORS跨域]]></title>
      <url>http://djl.pub/2017/03/25/CORS%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p>当访问其他域名或者同一域名不同端口上的资源时，就会产生跨域请求。而跨域请求确实是发起了，但是返回的结果却被浏览器拦截了，请求必须遵循的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">同源策略</a>。但是在工作中不可避免的会进行跨域访问。现在用的最多的就是Jsonp和cors但是jsonp只能发起get请求，而且携带数据量较小，如果要发起post请求，那么就要采用cors方案。<br><a id="more"></a></p>
<h2 id="允许跨域场景"><a href="#允许跨域场景" class="headerlink" title="允许跨域场景"></a>允许跨域场景</h2><p>跨源资源共享标准( cross-origin sharing standard ) 允许以下场景可以发起跨站 HTTP 请求：</p>
<ul>
<li>使用 XMLHttpRequest 或 Fetch发起跨站 HTTP 请求。</li>
<li>Web 字体 (CSS 中通过 @font-face使用跨站字体资源)</li>
<li>WebGL 贴图</li>
<li>使用drawImage 将 Images/video 画面绘制到canvas.</li>
<li>样式表（使用 CSSOM）</li>
<li>Scripts (未处理的异常)</li>
</ul>
<p>cors通过增加一些HTTP头，让服务器声明哪些源可以通过浏览器访问该服务器上的资源。其实也就是设置’Access-Control-Allow-Origin’,’*‘这个响应头，当然这里是允许所有来源，我们也可以具体指定。注意设置了credentials = true,就不能设置’Access-Control-Allow-Origin’, ‘*’,会报错。</p>
<h2 id="预请求"><a href="#预请求" class="headerlink" title="预请求"></a>预请求</h2><p>一般发起的跨域请求都会先发送预请求，服务器允许后，浏览器才会以真正的HTTP请求方式发送请求，这是出于服务器的安全。那么如果同时满足一下几种情况是不会发送预请求（请求方式为OPTIONS，这是HTTP1.1中新增的方式）的。</p>
<h3 id="请求方式必须是GET、POST、HEAD"><a href="#请求方式必须是GET、POST、HEAD" class="headerlink" title="请求方式必须是GET、POST、HEAD"></a>请求方式必须是GET、POST、HEAD</h3><h3 id="请求头除了是用户代理自动设置（例如：Connection-User-Agent）和如下请求头"><a href="#请求头除了是用户代理自动设置（例如：Connection-User-Agent）和如下请求头" class="headerlink" title="请求头除了是用户代理自动设置（例如：Connection, User-Agent）和如下请求头"></a>请求头除了是用户代理自动设置（例如：Connection, User-Agent）和如下请求头</h3><ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type (but note the additional requirements below)</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
<h3 id="Content-type必须要是如下值"><a href="#Content-type必须要是如下值" class="headerlink" title="Content-type必须要是如下值"></a>Content-type必须要是如下值</h3><ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
<p><strong>注意上面三个条件必须是同时满足</strong></p>
<p>例如POST请求，但是如果Content-type:application/json那么就会发起预请求。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>域为<a href="http://foo.example向域为http://bar.other的发起请求" target="_blank" rel="external">http://foo.example向域为http://bar.other的发起请求</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"><span class="keyword">var</span> url = <span class="string">'http://bar.other/resources/public-data/'</span>;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(invocation) &#123;    </div><div class="line">    invocation.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">    invocation.onreadystatechange = handler;</div><div class="line">    invocation.send(); </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://mdn.mozillademos.org/files/14293/simple_req.png" alt="示意图"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GET /resources/public-data/ HTTP/1.1</div><div class="line">Host: bar.other</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: en-us,en;q=0.5</div><div class="line">Accept-Encoding: gzip,deflate</div><div class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class="line">Connection: keep-alive</div><div class="line">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</div><div class="line">Origin: http://foo.example</div><div class="line"></div><div class="line"></div><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 01 Dec 2008 00:23:53 GMT</div><div class="line">Server: Apache/2.0.61 </div><div class="line">Access-Control-Allow-Origin: *</div><div class="line">Keep-Alive: timeout=2, max=100</div><div class="line">Connection: Keep-Alive</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Content-Type: application/xml</div></pre></td></tr></table></figure>
<p>我们可以看到响应头中设置了<code>Access-Control-Allow-Origin: *</code>，那么此时是能够正常拿到数据的。</p>
<h2 id="携带cookies"><a href="#携带cookies" class="headerlink" title="携带cookies"></a>携带cookies</h2><p>一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"><span class="keyword">var</span> url = <span class="string">'http://bar.other/resources/credentialed-content/'</span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(invocation) &#123;</div><div class="line">    invocation.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">    invocation.withCredentials = <span class="literal">true</span>;</div><div class="line">    invocation.onreadystatechange = handler;</div><div class="line">    invocation.send(); </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里只是设置了一个标志位，并不是一个请求头，所以这是一个简单请求，是不会发送预请求的。但是在服务器端一定要设置<code>Access-Control-Allow-Credentials:true</code>,不然浏览器不会把服务器端的结果返回给发起请求的script脚本，浏览器会报错。</p>
<h2 id="发起跨域请求时，服务器返回的部分HTTP响应头"><a href="#发起跨域请求时，服务器返回的部分HTTP响应头" class="headerlink" title="发起跨域请求时，服务器返回的部分HTTP响应头"></a>发起跨域请求时，服务器返回的部分HTTP响应头</h2><ul>
<li>Access-Control-Allow-Origin    设置允许的客户端代理。<strong>注意当设置值为*时，就不能在客户端设置withCredentials为TRUE</strong></li>
<li>Access-Control-Expose-Headers：设置浏览器可以的访问到的服务器头信息的白名单，如果设置，那么在浏览器端是可以看到服务器设置了哪些头信息。<blockquote>
<p>Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</p>
</blockquote>
</li>
<li>Access-Control-Max-Age：允许这个预请求可以缓存的时间，在设置时间内，将不再发送这个预请求</li>
<li>Access-Control-Allow-Credentials：设置服务器响应数据是否可以被<code>credentials</code>设置为TRUE的客户端拿到，如果为FALSE，那么响应数据客户端script脚本是拿不到的。</li>
<li>Access-Control-Allow-Methods：设置客户端发起请求的方式</li>
</ul>
<h2 id="HTTP-请求头"><a href="#HTTP-请求头" class="headerlink" title="HTTP 请求头"></a>HTTP 请求头</h2><ul>
<li>origin ：表明发起跨域请求的域</li>
<li>Access-Control-Request-Method ：这个是在发送预请求时，告诉服务器，真实请求的请求方式。</li>
<li>Access-Control-Request-Headers ：当发送预请求时，告诉服务器，发送真实请求时，所包含的请求头信息。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP access control (CORS)</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端跨域请求原理及实践]]></title>
      <url>http://djl.pub/2017/03/11/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="跨域请求的含义"><a href="#跨域请求的含义" class="headerlink" title="跨域请求的含义"></a>跨域请求的含义</h2><p>浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如JavaScript）对不同域的服务进行跨站调用。一般的，只要网站的 协议名protocol、主机host、端口号port这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。这也是我们下面实践的理论基础。我们利用NodeJs创建了两个服务器，分别监听3000、3001端口（下面简称服务器3000与服务器3001），由于端口号不一样，这两个服务器以及服务器上页面通信构成了跨域请求。在服务器3000 上有如下的页面：<br><a id="more"></a></p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3001_page.png" alt=""></p>
<p>服务器3000 上的请求页面中包含如下 JavaScript 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> data = &#123;</div><div class="line">            <span class="attr">name</span>: $(<span class="string">"#name"</span>).val(),</div><div class="line">            <span class="attr">id</span>: $(<span class="string">"#id"</span>).val()</div><div class="line">        &#125;;</div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">type</span>: <span class="string">'POST'</span>,</div><div class="line">            <span class="attr">data</span>: data,</div><div class="line">            <span class="attr">url</span>: <span class="string">'http://localhost:3000/ajax/deal'</span>,</div><div class="line">            <span class="attr">dataType</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">cache</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">timeout</span>: <span class="number">5000</span>,</div><div class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(data)</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'error '</span> + textStatus + <span class="string">' '</span> + errorThrown);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器3000 对应的处理函数为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.post(<span class="string">'/ajax/deal'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"server accept: "</span>, req.body.name, req.body.id)</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">        <span class="attr">name</span>: req.body.name + <span class="string">' - server 3000 process'</span>,</div><div class="line">        <span class="attr">id</span>: req.body.id + <span class="string">' - server 3000 process'</span></div><div class="line">    &#125;</div><div class="line">    res.send(data)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>请求页面返回结果：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3000.png" alt=""></p>
<p>此处数据处理成功。</p>
<p>由于数据请求一般都是由页面发送数据字段，服务器根据这些字段作相应的处理，如数据库查询，字符串操作等等。所以我们这里简单的处理数据（在数据后面加上字符串‘server3000process’），并且返回给浏览器，表示数据经过服务器端处理。如果让服务器3000上的页面向服务器3001发起请求会怎样呢？将请求页面中的ajax请求路径改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    ...</div><div class="line">    url: <span class="string">'http://localhost:3001/ajax/deal'</span>,</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器3001 对应的处理函数与 服务器3000 类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.post(<span class="string">'/ajax/deal'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"server accept: "</span>, req.body.name, req.body.id)</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">        <span class="attr">name</span>: req.body.name + <span class="string">' - server 3001 process'</span>,</div><div class="line">        <span class="attr">id</span>: req.body.id + <span class="string">' - server 3001 process'</span></div><div class="line">    &#125;</div><div class="line">    res.send(data)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3001_error.png" alt=""></p>
<p>结果证明了我们上面所说的端口号不同，发生了跨域请求的调用。需要注意的是，服务器 3001 控制台有输出：</p>
<blockquote>
<p>server accept:  chiaki 3001</p>
</blockquote>
<p>这说明跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。</p>
<h2 id="利用-JSONP-实现跨域调用"><a href="#利用-JSONP-实现跨域调用" class="headerlink" title="利用 JSONP 实现跨域调用"></a>利用 JSONP 实现跨域调用</h2><p>说道跨域调用，可能大家首先想到的或者听说过的就是 JSONP 了。</p>
<h3 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h3><blockquote>
<p>JSONP (JSON with Padding or JSON-P) is a JSON extension used by web developers to overcome the cross-domain restrictions imposed by browsers’ same-origin policy that limits access to resources retrieved from origins other than the one the page was served by. In layman’s terms, one website cannot just simply access the data from another website.<br>It was developed because handling a browsers’ same origin policy can be difficult, so using JSONP abstracts the difficulties and makes it easier.<br>JSON stands for “JavaScript Object Notation”, a format by which object fields are represented as key-value pairs which is used to represent data.</p>
</blockquote>
<p>JSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据XmlHttpRequest对象受到同源策略的影响，而script标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据,而是可以直接运行的 JavaScript 语句。</p>
<h3 id="使用-jQuery-集成的-ajax-实现-JSONP-跨域调用"><a href="#使用-jQuery-集成的-ajax-实现-JSONP-跨域调用" class="headerlink" title="使用 jQuery 集成的 $.ajax 实现 JSONP 跨域调用"></a>使用 jQuery 集成的 $.ajax 实现 JSONP 跨域调用</h3><p>我们先从简单的实现开始，利用jQuery中的$.ajax来实现上诉的跨域调用。依然是上面的例子，我们将服务器 3000 上的请求页面的 JavaScript 代码改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 回调函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"jsonpCallback: "</span> + data.name)</div><div class="line">&#125;</div><div class="line">$(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">        <span class="attr">name</span>: $(<span class="string">"#name"</span>).val(),</div><div class="line">        <span class="attr">id</span>: $(<span class="string">"#id"</span>).val()</div><div class="line">    &#125;;</div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://localhost:3001/ajax/deal'</span>,</div><div class="line">        <span class="attr">data</span>: data,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</div><div class="line">        <span class="attr">cache</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">timeout</span>: <span class="number">5000</span>,</div><div class="line">        <span class="comment">// jsonp 字段含义为服务器通过什么字段获取回调函数的名称</span></div><div class="line">        jsonp: <span class="string">'callback'</span>,</div><div class="line">        <span class="comment">// 声明本地回调函数的名称，jquery 默认随机生成一个函数名称</span></div><div class="line">        jsonpCallback: <span class="string">'jsonpCallback'</span>,</div><div class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"ajax success callback: "</span> + data.name)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(textStatus + <span class="string">' '</span> + errorThrown);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器 3001 上对应的处理函数为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/ajax/deal'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"server accept: "</span>, req.query.name, req.query.id)</div><div class="line">    <span class="keyword">var</span> data = <span class="string">"&#123;"</span> + <span class="string">"name:'"</span> + req.query.name + <span class="string">" - server 3001 process',"</span> + <span class="string">"id:'"</span> + req.query.id + <span class="string">" - server 3001 process'"</span> + <span class="string">"&#125;"</span></div><div class="line">    <span class="keyword">var</span> callback = req.query.callback</div><div class="line">    <span class="keyword">var</span> jsonp = callback + <span class="string">'('</span> + data + <span class="string">')'</span></div><div class="line">    <span class="built_in">console</span>.log(jsonp)</div><div class="line">    res.send(jsonp)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这里一定要注意 data 中字符串拼接，不能直接将 JSON 格式的data直接传给回调函数，否则会发生编译错误： <code>parsererror Error: jsonpCallback was not called。</code></p>
<p><strong><em>其实脑海里应该有一个概念：利用 JSONP 格式返回的值一段要立即执行的 JavaScript 代码，所以不会像 ajax 的 XmlHttpRequest 那样可以监听不同事件对数据进行不同处理。</em></strong></p>
<p>处理结果如下所示：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3001_ajax_jsonp.png" alt=""></p>
<h3 id="使用-script标签原生实现-JSONP"><a href="#使用-script标签原生实现-JSONP" class="headerlink" title="使用 script标签原生实现 JSONP"></a>使用 script标签原生实现 JSONP</h3><p>经过上面的事件，你是不是觉得JSONP的实现和Ajax大同小异？其实，由于实现的原理不同，由JSONP实现的跨域调用不是通过 XmlHttpRequset对象，而是通过script标签，所以在实现原理上，JSONP和Ajax已经一点关系都没有了。看上去形式相似只是由于 jQuery对JSONP做了封装和转换。比如在上面的例子中，我们假设要传输的数据 data 格式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    name: "chiaki",</div><div class="line">    id": "3001"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么数据是如何传输的呢？HTTP 请求头的第一行如下：</p>
<blockquote>
<p>GET /ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032 HTTP/1.1</p>
</blockquote>
<p>可见，即使形式上是用 POST 传输一个 JSON 格式的数据，其实发送请求时还是转换成 GET请求。其实如果理解 JSONP的原理的话就不难理解为什么只能使用GET请求方法了。由于是通过script标签进行请求，所以上述传输过程根本上是以下的形式：</p>
<p><code>&lt;script src = &#39;http://localhost:3001/ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032&#39;&gt;&lt;/script&gt;</code></p>
<p>这样从服务器返回的代码就可以直接在这个script标签中运行了。下面我们自己实现一个JSONP：服务器3000请求页面的 JavaScript 代码中，只有回调函数 jsonpCallback：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"jsonpCallback: "</span>+data.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务器 3000请求页面还包含一个 script 标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src = <span class="string">'http://localhost:3001/jsonServerResponse?jsonp=jsonpCallback'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>服务器 3001上对应的处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/jsonServerResponse'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cb = req.query.jsonp</div><div class="line">    <span class="built_in">console</span>.log(cb)</div><div class="line">    <span class="keyword">var</span> data = <span class="string">'var data = &#123;'</span> + <span class="string">'name: $("#name").val() + " - server 3001 jsonp process",'</span> + <span class="string">'id: $("#id").val() + " - server 3001 jsonp process"'</span> + <span class="string">'&#125;;'</span></div><div class="line">    <span class="keyword">var</span> debug = <span class="string">'console.log(data);'</span></div><div class="line">    <span class="keyword">var</span> callback = <span class="string">'$("#submit").click(function() &#123;'</span> + data + cb + <span class="string">'(data);'</span> + debug + <span class="string">'&#125;);'</span></div><div class="line">    res.send(callback)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>与上面一样，我们在所获取的参数后面加上“-server 3001 jsonp process”<br>代表服务器对数据的操作。从代码中我么可以看到，处理函数除了根据参数做相应的处理，更多的也是进行字符串的拼接。最终的结果为：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3001_jsonp.png" alt=""></p>
<h3 id="JSONP-总结"><a href="#JSONP-总结" class="headerlink" title="JSONP 总结"></a>JSONP 总结</h3><p>至此，我们了解了 JSONP 的原理以及实现方式，它帮我们实现前端跨域请求，但是在实践的过程中，我们还是可以发现它的不足：</p>
<p>只能使用 GET 方法发起请求，这是由于 script 标签自身的限制决定的。</p>
<p>不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数。</p>
<h2 id="使用-CORS-实现跨域调用"><a href="#使用-CORS-实现跨域调用" class="headerlink" title="使用 CORS 实现跨域调用"></a>使用 CORS 实现跨域调用</h2><h3 id="什么是-CORS？"><a href="#什么是-CORS？" class="headerlink" title="什么是 CORS？"></a>什么是 CORS？</h3><p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了Web服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是JSONP模式的现代版。与JSONP不同，CORS除了GET要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。</p>
<h3 id="CORS-的实现"><a href="#CORS-的实现" class="headerlink" title="CORS 的实现"></a>CORS 的实现</h3><p>还是以 服务器 3000 上的请求页面向 服务器 3001 发送请求为例。<br>服务器 3000 上的请求页面 JavaScript 不变，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> data = &#123;</div><div class="line">            <span class="attr">name</span>: $(<span class="string">"#name"</span>).val(),</div><div class="line">            <span class="attr">id</span>: $(<span class="string">"#id"</span>).val()</div><div class="line">        &#125;;</div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">type</span>: <span class="string">'POST'</span>,</div><div class="line">            <span class="attr">data</span>: data,</div><div class="line">            <span class="attr">url</span>: <span class="string">'http://localhost:3001/cors'</span>,</div><div class="line">            <span class="attr">dataType</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">cache</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">timeout</span>: <span class="number">5000</span>,</div><div class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(data)</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'error '</span> + textStatus + <span class="string">' '</span> + errorThrown);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器 3001上对应的处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">app.post(&apos;/cors&apos;, function(req, res) &#123;</div><div class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</div><div class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);</div><div class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</div><div class="line">    res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;)</div><div class="line">    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);</div><div class="line">    var data = &#123;</div><div class="line">        name: req.body.name + &apos; - server 3001 cors process&apos;,</div><div class="line">        id: req.body.id + &apos; - server 3001 cors process&apos;</div><div class="line">    &#125;</div><div class="line">    console.log(data)</div><div class="line">    res.send(data)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在服务器中对返回信息的请求头进行了设置。最终的结果为：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3001_cors.png" alt=""></p>
<h3 id="CORS-中属性的分析"><a href="#CORS-中属性的分析" class="headerlink" title="CORS 中属性的分析"></a>CORS 中属性的分析</h3><p>Access-Control-Allow-Origin</p>
<blockquote>
<p>The origin parameter specifies a URI that may access the resource. The browser must enforce this. For requests without credentials, the server may specify “*” as a wildcard, thereby allowing any origin to access the resource.</p>
</blockquote>
<p>Access-Control-Allow-Methods</p>
<blockquote>
<p>Specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</p>
</blockquote>
<p>Access-Control-Allow-Headers</p>
<blockquote>
<p>Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.</p>
</blockquote>
<h3 id="3-4-CORS-与-JSONP-的对比"><a href="#3-4-CORS-与-JSONP-的对比" class="headerlink" title="3.4 CORS 与 JSONP 的对比"></a>3.4 CORS 与 JSONP 的对比</h3><p>CORS 除了 GET 方法外，也支持其它的 HTTP 请求方法如 POST、 PUT 等。<br>CORS 可以使用 XmlHttpRequest 进行传输，所以它的错误处理方式比 JSONP 好。<br>JSONP 可以在不支持 CORS 的老旧浏览器上运作。</p>
<h2 id="一些其它的跨域调用方式"><a href="#一些其它的跨域调用方式" class="headerlink" title="一些其它的跨域调用方式"></a>一些其它的跨域调用方式</h2><h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重。</p>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage()"></a>window.postMessage()</h3><p>这个方法是 HTML5 的一个新特性，可以用来向其他所有的window对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送MessageEvent，如果在函数执行的过程中调用了他，就会让后面的函数超时无法执行。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="external">参考</a></p>
<blockquote>
<p>本文转自<a href="http://tingandpeng.com/2016/09/05/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">前端跨域请求原理及实践</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[better-scroll初探]]></title>
      <url>http://djl.pub/2017/02/13/better-scroll%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>在做外卖APP项目时，用到了better-scroll这个插件，接口基本和iscroll一致，功能非常强大。<br><a id="more"></a></p>
<h1 id="文档资料"><a href="#文档资料" class="headerlink" title="文档资料"></a>文档资料</h1><p><a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="external">官方文档</a><br>主要资料还是参考<a href="https://iiunknown.gitbooks.io/iscroll-5-api-cn/content/index.html" target="_blank" rel="external">iscroll</a>这个插件，API接口都是一致的</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>一定要有两层<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> myScroll = <span class="keyword">new</span> IScroll(<span class="string">'#wrapper'</span>);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.getElementById(<span class="string">'wrapper'</span>);</div><div class="line"><span class="keyword">var</span> myScroll = <span class="keyword">new</span> IScroll(wrapper);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：使用的是querySelector 而不是 querySelectorAll，所以iScroll只会作用到选择器选中元素的第一个。如果你需要对多个对象使用iScroll，你需要构建自己的循环机制。</p>
</blockquote>
<p>outer层设置固定大小且为挂载点，overflow:hidden,inner层就是随内容增加。</p>
<h1 id="相关设置参数："><a href="#相关设置参数：" class="headerlink" title="相关设置参数："></a>相关设置参数：</h1><p><strong>bounce</strong>:当滚动器到达容器边界时他将执行一个小反弹动画，默认值为TRUE<br><strong>click:true</strong>    允许点击事件，在这里如果这个设置为TRUE的话，在触发点击事件时，有可能会两次触发（在pc端），这里我们就要通过如下判断<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(event._constructor)&#123;</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过better-scroll包装后的event事件对象会都一个<code>_constructor</code>属性，如果不进行判断，可能会触发两次点击事件。<br><strong>scrollX:true</strong>   横向滚动<br><strong>eventPassThrough:vertical</strong> 这个参数是在元素在横向滚动的同时，也是允许外层容器纵向滚动的<br><strong>mouseWheel</strong>:侦听鼠标滚轮事件<br><strong>scrollbars</strong>:是否显示为默认的滚动条<br>监听滚动事件，用于获取滚动高度<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(<span class="built_in">document</span>.getElementById(<span class="string">'wrapper'</span>),&#123;</div><div class="line">   <span class="attr">probeType</span>: <span class="number">3</span>  <span class="comment">//调节在scroll事件触发中探针的活跃度</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">scroll.on(<span class="string">'scroll'</span>, (pos) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(pos.x + <span class="string">'~'</span> + posx.y)</div><div class="line">  ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><a href="https://iiunknown.gitbooks.io/iscroll-5-api-cn/content/basicfeatures.html" target="_blank" rel="external">更多配置</a></p>
<h1 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h1><p><strong>滚动到某个元素</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(<span class="built_in">document</span>.getElementById(<span class="string">'wrapper'</span>))</div><div class="line">scroll.scrollToElement(el, <span class="number">500</span>)</div><div class="line"><span class="comment">// 第一个参数为X轴，第二个参数为Y轴</span></div></pre></td></tr></table></figure></p>
<p><strong>滚动到某个坐标</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(<span class="built_in">document</span>.getElementById(<span class="string">'wrapper'</span>))</div><div class="line">scroll.scrollTo(<span class="number">0</span>, <span class="number">500</span>)</div><div class="line"><span class="comment">// 第一个参数为X轴，第二个参数为Y轴</span></div></pre></td></tr></table></figure></p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>1 在使用b-scroll的时候，能够准确把握b-scroll初始化的时机是非常重要的。有些时候滚动是由于里面的内容撑开所导致，所以一定要保证里面的内容中的异步数据充分拿到之后进行b-srcoll初始化，所以我们必须要通过Vue的watch监听机制，在监听到数据变化的时候也进行一次b-scroll初始化，当然在ready时候也要进行初始化，因为当我们通过Vue-router进行切换时，整个DOM是重新加载的，但是watch监听数据变化是不会触发的，所以我们就必要在ready的时候进行一次初始化（当然这里也可以使用keep-alive属性阻止DOM重绘）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ready () &#123;</div><div class="line">    <span class="comment">// b-scroll 初始化</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">watch</span>: &#123;</div><div class="line">    <span class="string">'seller'</span>() &#123;</div><div class="line">      <span class="comment">// 检测异步数据seller是否获取到，获取到则scroll 初始化</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2 我们在获取滚动条位置时，一定要保证DOM已经重新绘制。在js中我们一般要这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ajax(<span class="string">'page.php'</span>, onCompletion);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCompletion</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Update here your DOM</span></div><div class="line"></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        myScroll.refresh();</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当然在vue中直接使用<code>this.$nextTick()</code>。当然我们不需要每次都来初始化b-scroll，我们只需要初始化一次，后面只需要刷新即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hScroll) &#123;</div><div class="line">        <span class="keyword">this</span>.hScroll = <span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$els.hScrollHook, &#123;</div><div class="line">            <span class="attr">scrollX</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">eventPassthrough</span>: <span class="string">'vertical'</span></div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.hScroll.refresh();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="其他的一些scroll插件"><a href="#其他的一些scroll插件" class="headerlink" title="其他的一些scroll插件"></a>其他的一些scroll插件</h1><p><a href="https://github.com/mkay581/scroll-js" target="_blank" rel="external">scroll.js</a>  主要接口和better-scroll差不多，但是功能没有那么强大，不过容易使用</p>
<p><a href="https://github.com/alicelieutier/smoothScroll" target="_blank" rel="external">smoothScroll</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> smoothScroll = <span class="built_in">require</span>(<span class="string">'smoothscroll'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> exampleBtn = <span class="built_in">document</span>.querySelector(<span class="string">'.example-button'</span>);</div><div class="line"><span class="keyword">var</span> exampleDestination = <span class="built_in">document</span>.querySelector(<span class="string">'.example-destination'</span>);</div><div class="line"></div><div class="line"><span class="comment">// This function can easily be an onClick handler in React components</span></div><div class="line"><span class="keyword">var</span> handleClick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  event.preventDefault();</div><div class="line"></div><div class="line">  smoothScroll(exampleDestination);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">exampleBtn.addEventListener(<span class="string">'click'</span>, handleClick);</div></pre></td></tr></table></figure></p>
<p>使用很简单就像锚点一样，直接跳到某个元素那里。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue-resource初探]]></title>
      <url>http://djl.pub/2017/02/12/vue-resource%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>vue-resource是用来发送ajax请求或者解决jsonp跨域问题，既可以在全局Vue中使用（即Vue.$http）也可以在vue实例中使用（即this.$http）<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>npm <code>$ npm install vue-resource</code><br>cdn  <code>&lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.0.3/vue-resource.min.js&quot;&gt;&lt;/script&gt;</code></p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>最常见的用法，目前还需要掌握这些<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GET /someUrl</span></div><div class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/someUrl'</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// success callback</span></div><div class="line">&#125;, (response) =&gt; &#123;</div><div class="line">  <span class="comment">// error callback</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果没有es6解析环境就不要写成箭头函数的形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// global Vue object</span></div><div class="line">Vue.http.get(<span class="string">'/someUrl'</span>, [options]).then(successCallback, errorCallback);</div><div class="line">Vue.http.post(<span class="string">'/someUrl'</span>, [body], [options]).then(successCallback, errorCallback);</div></pre></td></tr></table></figure>
<p>也可以vue实例中使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in a Vue instance</span></div><div class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/someUrl'</span>, [options]).then(successCallback, errorCallback);</div><div class="line"><span class="keyword">this</span>.$http.post(<span class="string">'/someUrl'</span>, [body], [options]).then(successCallback, errorCallback);</div></pre></td></tr></table></figure></p>
<p>一般我们请求的数据都会是一个对象或者字符串，我们通过response.body来获取响应内容，如果我们请求的是图片这样的二进制文件，我们通过response.blob来获取内容主题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="comment">// POST /someUrl</span></div><div class="line">  <span class="keyword">this</span>.$http.post(<span class="string">'/someUrl'</span>, &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">  </div><div class="line">    <span class="comment">// get body data</span></div><div class="line">    <span class="keyword">this</span>.someData = response.body;</div><div class="line"></div><div class="line">  &#125;, response =&gt; &#123;</div><div class="line">    <span class="comment">// error callback</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者图片等等二进制大文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/image.jpg'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// resolve to Blob</span></div><div class="line">  <span class="keyword">return</span> response.blob();</div><div class="line">  </div><div class="line">  &#125;).then(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// use image Blob</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p><a href="https://github.com/pagekit/vue-resource/blob/develop/docs/http.md" target="_blank" rel="external">response对象</a></p>
<h1 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h1><p><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="external">官方文档</a><br><a href="http://www.cnblogs.com/keepfool/p/5657065.html" target="_blank" rel="external">参考资料</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue-router初探]]></title>
      <url>http://djl.pub/2017/02/08/vue-router%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>最近在跟着视频学习开发一个外卖APP单页运用，开发中用到了vue-router来做路由管理，现在来进行简单的总结。<br><a id="more"></a></p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/home' &#125;"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/about' &#125;"</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"home"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>home<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"about"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>about<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> App=Vue.extend(&#123;&#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> home=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#home'</span></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> about=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#about'</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        <span class="keyword">var</span> vueRouter=<span class="keyword">new</span> VueRouter();</div><div class="line">        vueRouter.map(&#123;</div><div class="line">            <span class="string">'/home'</span>:&#123;</div><div class="line">                <span class="attr">component</span>:home</div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/about'</span>:&#123;</div><div class="line">                <span class="attr">component</span>:about</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        vueRouter.start(App,<span class="string">'#container'</span>);</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>注意：我们在使用Vue-router时不需要显示的创建Vue实例，我们只需要通过<code>vueRouter.start(App,&#39;#container&#39;);</code>将根组件<br>挂载到某个元素下就可以</strong></p>
<p>当然这里我们在打开<em><a href="http://localhost:63342/VueTest/vue-router-study.html#!/" target="_blank" rel="external">http://localhost:63342/VueTest/vue-router-study.html#!/</a></em>这个路径时router-view中的内容并不会显示<br>这里我们要定义一个主页,我们可以使用redirect进行重定向<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vueRouter.redirect(&#123;</div><div class="line">    <span class="string">'/'</span>:<span class="string">'/home'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>官方解释:为路由器定义全局的重定向规则。全局的重定向会在匹配当前路径之前执行。<br>如果发现需要进行重定向，原本访问的路径会被直接忽略而且不会在浏览器历史中留下记录。</p>
</blockquote>
<p>当然我们也可以使用go()方法直接导航到一个新的路由<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vueRouter.go(<span class="string">'/home'</span>);</div></pre></td></tr></table></figure></p>
<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><p>在一个路由中嵌套路由是一种比较常见的情况。直接看实例代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/home' &#125;"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/about' &#125;"</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"home"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>home<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123;path:'/home/article'&#125;"</span>&gt;</span>我的文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"article"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一篇文章，DJL箫氏<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"about"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>about<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> App=Vue.extend(&#123;&#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> article=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#article'</span>,</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> home=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#home'</span>,</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> about=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#about'</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        <span class="keyword">var</span> vueRouter=<span class="keyword">new</span> VueRouter();</div><div class="line">        vueRouter.map(&#123;</div><div class="line">            <span class="string">'/home'</span>:&#123;</div><div class="line">                <span class="attr">component</span>:home ,</div><div class="line">                <span class="attr">subRoutes</span>:&#123;</div><div class="line">                    <span class="string">'/article'</span>:&#123;</div><div class="line">                        <span class="attr">component</span>:article</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/about'</span>:&#123;</div><div class="line">                <span class="attr">component</span>:about</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        vueRouter.go(<span class="string">'/home'</span>);</div><div class="line">        vueRouter.start(App,<span class="string">'#container'</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>由示例可知，我们需要在子组件内部去使用v-link和router-view。</p>
<h1 id="v-link"><a href="#v-link" class="headerlink" title="v-link"></a>v-link</h1><p>v-link该指令接受一个 JavaScript 表达式，并会在用户点击元素时用该表达式的值去调用 router.go<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 字面量路径 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"'home'"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 效果同上 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: 'home' &#125;"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 具名路径 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当点击v-link所在的元素时，该元素会被添加一个<code>.v-link-active</code>的class，通过这个class我们可以用来表示当前选中激活状态。<br>当然如果我们不想用这个类名，我们可以通过linkActiveClass 来设置，或者在内联元素上单独设置<code>&lt;a v-link=&quot;{ path: &#39;/a&#39;, activeClass: &#39;custom-active-class&#39; }&quot;&gt;&lt;/a&gt;</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">    <span class="attr">linkActiveClass</span>: <span class="string">'active'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="具名路径"><a href="#具名路径" class="headerlink" title="具名路径"></a>具名路径</h1><p>当我们一个路径过长时，我们就可以找一个别名来代替这个路径，然后还可以设置参数。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123;name:'articleName',params:&#123;id:1&#125;&#125;"</span>&gt;</span>我的文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123;name:'articleName',params:&#123;id:2&#125;&#125;"</span>&gt;</span>我的文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123;name:'articleName',params:&#123;id:3&#125;&#125;"</span>&gt;</span>我的文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"article"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第&#123;&#123;$route.params.id&#125;&#125;篇文章，DJL箫氏<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> App=Vue.extend(&#123;&#125;);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> article=Vue.extend(&#123;</div><div class="line">        <span class="attr">template</span>:<span class="string">'#article'</span>,</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> vueRouter=<span class="keyword">new</span> VueRouter();</div><div class="line">    vueRouter.map(&#123;</div><div class="line">        <span class="string">'/article/:id'</span>:&#123;</div><div class="line">            <span class="attr">name</span>:<span class="string">'articleName'</span>,</div><div class="line">            <span class="attr">component</span>:article</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    vueRouter.go(<span class="string">'/article'</span>);</div><div class="line">    vueRouter.start(App,<span class="string">'#container'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们可以通过vue-router提供的相关接口取到对应的值 <a href="https://github.com/vuejs/vue-router/blob/1.0/docs/zh-cn/route.md" target="_blank" rel="external">路由规则和路由匹配</a></p>
<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:seller</span>=<span class="string">'seller'</span> <span class="attr">keep-alive</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们加上了<code>keep-alive</code>这个属性，当我们不加的时候，每次切换路由都会重新加载DOM，这样就会出现一些问题，例如下图</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-2-8/4536530-file_1486560148439_faff.jpg" alt="keep-alive示例图"></p>
<p>我们此时在<em>商品</em>路由下面有两个实物加入了购物车，这是此时的状态，加入我们不加<code>keep-alive</code>我们切换到<em>评论</em>路由，然后再切换到<em>商品</em>路由，由于DOM会刷新，那么我们此时的已经加入购物车的状态就会清空，这显示不是我们想要的。如下图：</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-2-8/65884667-file_1486560396173_c4d9.jpg" alt=""></p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>我使用Vue-router（0.7.3）来作路由管理，由于我们的Vue是1.0版本所以Vue-router要选用0.7.3而不是2.0的版本,对应关系如下：</p>
<blockquote>
<p>Vue 2.0  —  Vue-router 2.0   <a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="external">Vue-router 2.0 文档</a></p>
<p>Vue 1.0  —  Vue-router 0.7.3 <a href="https://github.com/vuejs/vue-router/tree/1.0/docs/zh-cn" target="_blank" rel="external">Vue-router 0.7.3 文档</a></p>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>上面写的是我最基本的用法，也是我目前用到的，当然他还有很多用途，现在还没用到，等用到的时候再加上，最后附上另一篇参考文章。<a href="http://www.cnblogs.com/keepfool/p/5690366.html" target="_blank" rel="external">Vue.js——vue-router 60分钟快速入门</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webpack1.0初探]]></title>
      <url>http://djl.pub/2017/02/07/webpack1.0%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>webpack是目前最热门的前端资源模块化管理和打包工具,它能把各种资源，包括 jxs、coffeeJS、less／sass，甚至图片，当作模块来加载和使用。当我们需要使用这些资源时只需要require进来，方便模块化开发。<br><a id="more"></a></p>
<h1 id="webpack-使用"><a href="#webpack-使用" class="headerlink" title="webpack 使用"></a><a href="https://webpack.github.io/docs/usage.html" target="_blank" rel="external">webpack 使用</a></h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先全局安装<code>webpack $npm install webpack -g</code></p>
<p>再安装<code>webpack-dev-server</code>这是一个webpack提供的静态开发环境服务器，用来开发调试</p>
<blockquote>
<p>注：如果是在开发环境中用到的包我们使用<code>--save-dev</code>的参数，如果生产环境用到的如jQuery，我们直接只用<code>save</code>参数</p>
</blockquote>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>使用webpack最重要的就是配置文件<code>webpack.config.js</code>，和gulp等等工具一样都有一个配置文件</p>
<h2 id="常用配置选项"><a href="#常用配置选项" class="headerlink" title="常用配置选项"></a>常用配置选项</h2><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">entry : &#123;</div><div class="line">    <span class="string">'admin'</span>: <span class="string">'./admin/admin.js'</span>,</div><div class="line">    <span class="string">'custom'</span>:<span class="string">'./custom/custom.js'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>entry表示webpack的入口文件，可以是多个，那么webpack会一次执行。</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output:&#123;</div><div class="line">    <span class="attr">filename</span>:<span class="string">"[name].bundle.js"</span>,</div><div class="line">    <span class="attr">path</span>:path.join(__dirname,<span class="string">'dist'</span>),</div><div class="line">    <span class="attr">publicPath</span>:<span class="string">'/dist/'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>filename</code>编译后输出文件的名字<br><code>path</code>:编译后文件的存储位置</p>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins: []"></a>plugins: []</h3><h4 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h4><p>代码压缩 UglifyJsPlugin。这是一个webpack内置的插件，我们在使用时，只需要在webpack.config.js 引入，然后在plugins选项中注册</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="attr">plugins</span>:[<span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">             <span class="attr">compress</span>: &#123;</div><div class="line">                 <span class="attr">warnings</span>: <span class="literal">false</span></div><div class="line">             &#125;</div><div class="line">         &#125;)]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>他会将所有的js文件进行压缩，但是我们只希望生成环境的代码压缩，开发环境的文件并不希望压缩</p>
<p>如果我们只想在build时候uglify,那么我们可以设置一个参数，在build的启动项中，然后利用第三方包<code>node-argv</code>去读这个参数，然后就可以通过if来进行判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> args = <span class="built_in">require</span>(<span class="string">'node-argv'</span>);</div><div class="line"><span class="keyword">if</span>(args.minify)&#123;<span class="comment">// 这个minify就是自己设置的参数</span></div><div class="line">    <span class="comment">// toDo ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种是读取环境变量的方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line"><span class="keyword">var</span> env = process.env.NODE_ENV;</div><div class="line"><span class="keyword">if</span>(env === <span class="string">'production'</span>)&#123;</div><div class="line">    <span class="comment">// toDo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"start"</span>: <span class="string">"NODE_ENV=dev webpack-dev-server --progress --colors --hot --inline --d"</span>,</div><div class="line">    <span class="attr">"bulid"</span>: <span class="string">"NODE_ENV=producrion webpack-dev-server --progress --colors --hot --inline --d"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"></div><div class="line"><span class="comment">// definePlugin 会把定义的string 变量插入到Js代码中。</span></div><div class="line"><span class="keyword">var</span> definePlugin = <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">  <span class="attr">__DEV__</span>: <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(process.env.BUILD_DEV || <span class="string">'true'</span>)),</div><div class="line">  <span class="attr">__PRERELEASE__</span>: <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(process.env.BUILD_PRERELEASE || <span class="string">'false'</span>))</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./main.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [definePlugin]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>配置完成后，就可以使用 <code>BUILD_DEV=1 BUILD_PRERELEASE=1</code> webpack来打包代码了。 值得注意的是，<code>webpack -p</code>会删除所有无作用代码，也就是说那些包裹在这些全局变量下的代码块都会被删除，这样就能保证这些代码不会因发布上线而泄露。</p>
<h4 id="Open-Browser-Webpack-Plugin"><a href="#Open-Browser-Webpack-Plugin" class="headerlink" title="Open Browser Webpack Plugin"></a><a href="https://github.com/baldore/open-browser-webpack-plugin" target="_blank" rel="external">Open Browser Webpack Plugin</a></h4><p>使用<br><code>npm i --save-dev open-browser-webpack-plugin</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> OpenBrowserPlugin = <span class="built_in">require</span>(<span class="string">'open-browser-webpack-plugin'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: path.resolve(__dirname, <span class="string">'lib/entry.js'</span>),</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: __dirname + <span class="string">"/bundle/"</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">"bundle.js"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> OpenBrowserPlugin(&#123; <span class="attr">url</span>: <span class="string">'http://localhost:3000'</span> &#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>详细配置请见<a href="https://github.com/baldore/open-browser-webpack-plugin" target="_blank" rel="external">官网</a></p>
<h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p><a href="https://webpack.github.io/docs/list-of-loaders.html" target="_blank" rel="external">loader lists</a></p>
<h4 id="css-样式文件"><a href="#css-样式文件" class="headerlink" title="css 样式文件"></a>css 样式文件</h4><p> css-loader的作用是将css文件写入一个js文件里面</p>
<p> style-loader的作用就是将这个转换后的样式文件解析插入到HTML中</p>
<p> loader 有两种配置方法，一种是给每个entry文件单独添加loader例如<code>require(&#39;style!css!./admin.css&#39;);</code>注意在这里每一个loader后面都有一个”!”。这个顺序是<em>从右往左</em>的<br>另一种方式是在webpack.config.js文件中整体配置使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [&#123;</div><div class="line">            <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</div><div class="line">            <span class="attr">loaders</span>:[<span class="string">'style'</span>,<span class="string">'css'</span>]</div><div class="line">        &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>统一使用loaders:[]数组的方式</p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>对于引用图片有两种引用模式，一种是直接require，另一种是转换成base64（一般针对小图标）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">loaders: [</div><div class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">loader</span>: <span class="string">'file-loader'</span>&#125;,</div><div class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125; <span class="comment">// 内联的base64的图片地址，图片要小于8k，直接的url的地址则不解析</span></div><div class="line">    ]</div></pre></td></tr></table></figure></p>
<h4 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h4><p>node-sass模块和sass-loader。<br><a href="https://github.com/jtangelder/sass-loader" target="_blank" rel="external">参考资料</a></p>
<h4 id="ES6-加载"><a href="#ES6-加载" class="headerlink" title="ES6 加载"></a>ES6 加载</h4><p>这个依赖了3个模块<code>Babel-loader加载器</code>、<code>babel-preset-es2015</code>、<code>babel-core</code>。当然<br>如果是在react中使用还要依赖<code>babel-preset-react</code>。两种方式使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  <span class="attr">loaders</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.js?$/</span>,</div><div class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">      <span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">      <span class="attr">query</span>: &#123;</div><div class="line">        <span class="attr">presets</span>: [<span class="string">'es2015'</span>]</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">   <span class="attr">loaders</span>:[</div><div class="line">     &#123;</div><div class="line">       <span class="attr">test</span>: <span class="regexp">/\.js[x]?$/</span>,</div><div class="line">       <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">       <span class="attr">loader</span>: <span class="string">'babel-loader?presets[]=es2015'</span></div><div class="line">     &#125;,</div><div class="line">   ]</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><em>NOTE:The query string is appended to the loader with ?. i.e. url-loader?mimetype=image/png.</em></p>
<p>当然也可以配置一个.babelrc的配置文件<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">"presets"</span>: [ <span class="string">"es2015"</span> ] &#125;</div></pre></td></tr></table></figure></p>
<h3 id="resolve-配置选项"><a href="#resolve-配置选项" class="headerlink" title="resolve 配置选项"></a>resolve 配置选项</h3><p>如果你希望在require文件时省略文件的扩展名，只需要在webpack.config.js中添加 resolve.extensions 来配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">  <span class="comment">// 现在你require文件的时候可以直接使用require('file')，不用使用require('file.coffee')</span></div><div class="line">  extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.coffee'</span>]  <span class="comment">// 但是必须要在前面加一个空的字符串，否则会导致无法加载的情况</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优化通用代码"><a href="#优化通用代码" class="headerlink" title="优化通用代码"></a>优化通用代码</h3><p>Feed和Profile页面存在大量通用代码(比如React、公共的样式和组件等等)。webpack可以抽离页面间公共的代码，生成一个公共的bundle文件，供这两个页面缓存使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> commonsPlugin =</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>); <span class="comment">// 引入插件</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">    <span class="attr">Profile</span>: <span class="string">'./profile.js'</span>,</div><div class="line">    <span class="attr">Feed</span>: <span class="string">'./feed.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">'build'</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].js'</span> <span class="comment">// 为上面entry的key值</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [commonsPlugin]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在上一步引入自己的bundle之前引入<script src="build/common.js"></script></p>
<h3 id="生成Source-Maps（使调试更容易）"><a href="#生成Source-Maps（使调试更容易）" class="headerlink" title="生成Source Maps（使调试更容易）"></a>生成Source Maps（使调试更容易）</h3><p>开发总是离不开调试，如果可以更加方便的调试当然就能提高开发效率，<br>不过打包后的文件有时候你是不容易找到出错了的地方对应的源代码的位置的，Source Maps就是来帮我们解决这个问题的。<br>通过简单的配置后，Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，<br>使得编译后的代码可读性更高，也更容易调试。</p>
<p>在webpack的配置文件中配置source maps，需要配置devtool，<br>它有以下四种不同的配置选项，各具优缺点，描述如下：</p>
<p>devtool选项   配置结果</p>
<p><code>source-map</code>     在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度；</p>
<p><code>cheap-module-source-map</code>   在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</p>
<p><code>eval-source-map</code>   使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项；</p>
<p><code>cheap-module-eval-source-map</code>  这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</p>
<p>正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。</p>
<p>在学习阶段以及在小到中性的项目上，eval-source-map是一个很好的选项，不过记得只在开发阶段使用它，继续上面的例子，进行如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  devtool: &apos;eval-source-map&apos;,//配置生成Source Maps，选择合适的选项</div><div class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/public&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>cheap-module-eval-source-map</code>方法构建速度更快，但是不利于调试，推荐在大型项目考虑da时间成本是使用。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>我们可以直接通过webpack-dev-server（前提是全局安装）命令直接在命令窗口中启动，也可以通过设置package.json<br>一个启动项，例如：<code>&quot;start&quot;: &quot;webpack-dev-server --progress --colors --hot --inline&quot;</code>这里就不需要webpack-dev-server<br>这个包是全局安装。这种启动方式，寻找包会到local环境中查找，找不到再去查找全局。</p>
<p><code>--progress</code>这个参数是显示进度</p>
<p><code>--colors</code> 显示颜色，这样命令窗口看起来比较爽</p>
<p><code>--hot</code> 启动热加载，就是文件保存，浏览器自动刷新，类似于liveonload这个功能</p>
<p><code>--inline</code> 把内容注入到相应文件中</p>
<p><code>--d</code> 开启debug模式，这样在浏览器中我们就可以看到源码</p>
<p>在entry的js文件里面可以require任何一个文件(css,js等等)</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>1  视频老师用的是mac系统，正则匹配文件路径时这样<code>/\/images\//</code>，但是我的是Windows的系统所以文件路径匹配应该是这样<code>/\\img\\/</code></p>
<p>2 在webpack.config.js配置文件中，应该是不能使用ES6的语法的。</p>
<h1 id="不错的webpack资料"><a href="#不错的webpack资料" class="headerlink" title="不错的webpack资料"></a>不错的webpack资料</h1><p><a href="https://github.com/petehunt/webpack-howto/blob/master/README-zh.md" target="_blank" rel="external">webpack-howto</a></p>
<p><a href="http://www.maiziedu.com/course/570/" target="_blank" rel="external">视频资料</a></p>
<p><a href="https://segmentfault.com/a/1190000008032524" target="_blank" rel="external">webpack 入门实战</a></p>
<p><a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">阮一峰老师webpack</a></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>感觉这篇写的并不是很好，然而webpack2.0出来了，我1.0才开始，嗯对Vue似乎也是这样。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vuex初探]]></title>
      <url>http://djl.pub/2017/01/29/Vuex%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>前篇我们谈到在<a href="http://djl.pub/2017/01/21/Vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E4%BB%B6/#组件通信">Vue组件中进行通信的几种方式</a>，父子组件中可以通过props属性，兄弟组件可以通过事件分发。当然很明显组件的独立性会有所降低，那么这里有另外一种方式就是通过Vuex。核心思想就是把子组件中需要共享的数据通过Vuex来进行管理。这里我使用的是Vuex1.0版本。<br><a id="more"></a></p>
<p><a href="https://github.com/vuejs/vuex/tree/1.0/docs/zh-cn" target="_blank" rel="external">官方文档1.0</a></p>
<p>Vuex 1.0 和 2.0都完全支持 Vue 1.0 和 2.0。上面是1.0版本的文档，千万不要安装的2.0版本，查看的却是1.0的文档资料</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vuex@1.0.0</div></pre></td></tr></table></figure>
<p>这里我们以一个例子来讲解Vuex的基本使用。我们实现一个计数器，实现加一和减一功能。这里我们创建3个组件<code>Display.vue</code>、<code>Increment.vue</code>和<code>Decrement.vue</code>。很简单我们可以分析出这三个组件中会共享一个数据那就是<code>count</code>，都需要知道当前计数器的数值是多少。所以这个数据要放在Vuex中进行管理，以后<code>Display.vue</code>、<code>Increment.vue</code>和<code>Decrement.vue</code>这三个组件就是通过访问Vuex来操作<code>count</code>这个数据。</p>
<h2 id="Vuex基本流程"><a href="#Vuex基本流程" class="headerlink" title="Vuex基本流程"></a>Vuex基本流程</h2><p>在这里首先借用官方文档中的一幅图片</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-29/63997298-file_1485700766566_d0e.png" alt="Vuex流程图"></p>
<p>从这里我们会知道一下几个核心概念</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在使用Vuex时，我们一般会有如下文件结构：</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-29/92859228-file_1485701346600_9217.jpg" alt="Vuex基本文件结构"></p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>state对象保存的就是共享数据的当前状态</p>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>提供操作共享数据的具体方法，能够直接操作state对象。</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>在vue组件中，我们可以直接通过this.$store来访问共享数据，但是我们一般不会这么做，我们还是通过Vuex提供的getter属性来取得。</p>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><blockquote>
<p>action 是一种专门用来被 component 调用的函数。action 函数能够通过分发相应的 mutation 函数，来触发对 store 的更新。action 也可以先从 HTTP 后端或 store 中读取其他数据之后再分发更新事件。</p>
</blockquote>
<p>actions不能直接操作state数据的，而是通过dispatch相应的mutations来实现。一般组件直接调用的就是actions中提供的函数接口，而不会去直接调用mutations。</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-29/32989864-file_1485700769110_11d56.jpg" alt=""></p>
<p>上图是我自己画的一个调用关系图，从上面我们可以看到，调用过程还是比较复杂的，所以如果是比较小的项目，就不要使用Vuex了。</p>
<h2 id="开始动手吧"><a href="#开始动手吧" class="headerlink" title="开始动手吧"></a>开始动手吧</h2><p>首先我们通过vue-cli脚手架搭建一个vue工程，如果不是很清楚可以看看我的另一篇博客。然后我们构建<code>Display.vue</code>、<code>Increment.vue</code>和<code>Decrement.vue</code>三个组件。然后新建一个vuex文件夹下面有<code>store.js</code>、<code>actions.js</code>和<code>getters.js</code>。工程目录结构如下图所示。</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-29/90277051-file_1485702257444_17c2d.jpg" alt="计数器工程目录结构"></p>
<h3 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="comment">//告诉Vue使用vuex</span></div><div class="line">Vue.use(Vuex);</div><div class="line"></div><div class="line"><span class="comment">//创建一个对象来保存应用启动时的初始状态</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> state = &#123;</div><div class="line"><span class="comment">// 应用启动时，count为0</span></div><div class="line">    count: <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建一个对象存储一系列我们接下来要写的mutation函数</span></div><div class="line"><span class="keyword">const</span> mutations = &#123;</div><div class="line"><span class="comment">//    放置我们状态变更函数</span></div><div class="line">    INCREMENT (state,amount) &#123;</div><div class="line">         state.count = state.count + amount;</div><div class="line">    &#125;,</div><div class="line">    DECREMENT (state,amount) &#123;</div><div class="line">        state.count = state.count - amount;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//整合初始状态和变更函数，我们就得到了我们所需的store</span></div><div class="line"><span class="comment">// 至此，这个store就可以连接到我们的应用中</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    state,</div><div class="line">    mutations</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>简单来说这个文件就做了几件事<br>1 告诉vue我们这个项目使用了vuex<br>2 定义添加共享数据count<br>3 提供操作共享数据的相关函数接口<code>INCREMENT</code>、<code>DECREMENT</code><br>4 导出这个store供外部使用</p>
<h3 id="actions-js"><a href="#actions-js" class="headerlink" title="actions.js"></a>actions.js</h3><p>action 是一种专门用来被 component 调用的函数。也就是说<code>Display.vue</code>、<code>Increment.vue</code>和<code>Decrement.vue</code>三个组件可能要使用actions.js。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> incrementCounter = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;dispatch, state&#125;</span>) </span>&#123;</div><div class="line">     dispatch(<span class="string">'INCREMENT'</span>,<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrementCounter = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;dispatch, state&#125;</span>) </span>&#123;</div><div class="line">    dispatch(<span class="string">'DECREMENT'</span>,<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>dispatch中的字符串参数一定要和store.js中mutations对象中的名字对应</strong><br>这里我们可以通过dispatch给对应mutations中的函数提供参数，这里就是<code>1</code>。</p>
<h3 id="Increment-vue"><a href="#Increment-vue" class="headerlink" title="Increment.vue"></a>Increment.vue</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'increment'</span>&gt;</span>Increment +1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">import</span> &#123; incrementCounter &#125; <span class="keyword">from</span> <span class="string">'../vuex/action'</span></div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">        <span class="attr">vuex</span>:&#123;</div><div class="line">            <span class="attr">actions</span>:&#123;</div><div class="line">                <span class="attr">increment</span>:incrementCounter</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当我们点击按钮时，会触发click事件调用<code>increment</code>方法，从而调用<code>incrementCounter</code>这个action，通过这个action调用直接操作数据的mutation。于是就这样实现了加一操作。</p>
<h3 id="Display-vue"><a href="#Display-vue" class="headerlink" title="Display.vue"></a>Display.vue</h3><p>接下来就是通过Display.vue这个组件来显示</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;counterValue&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">import</span> &#123; getCount &#125; <span class="keyword">from</span> <span class="string">'../vuex/getters'</span></div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">        <span class="attr">vuex</span>:&#123;</div><div class="line">          <span class="attr">getters</span>:&#123;</div><div class="line">            <span class="attr">counterValue</span>:getCount</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们可以看到并没有直接这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vuex:&#123;</div><div class="line">  <span class="attr">getters</span>:&#123;</div><div class="line">    counterValue (state) &#123;</div><div class="line">     <span class="keyword">return</span> state.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>1 我们可能需要使用 getter 函数返回需经过计算的值（比如总数，平均值等）。<br>2 在大型应用里，很多组件之间可以复用同一个 getter 函数。<br>3 如果这个值的位置改变了（比如从 store.count 变成了 store.counter.value），你只需要改一个 getter 方法，而不是一堆组件。</p>
</blockquote>
<h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Increment</span>&gt;</span><span class="tag">&lt;/<span class="name">Increment</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Decrement</span>&gt;</span><span class="tag">&lt;/<span class="name">Decrement</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Display</span>&gt;</span><span class="tag">&lt;/<span class="name">Display</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">import</span> Increment <span class="keyword">from</span> <span class="string">'./components/Increment'</span></div><div class="line"><span class="keyword">import</span> Decrement <span class="keyword">from</span> <span class="string">'./components/Decrement'</span></div><div class="line"><span class="keyword">import</span> Display <span class="keyword">from</span> <span class="string">'./components/Display'</span></div><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./vuex/store'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    Increment,</div><div class="line">    Decrement,</div><div class="line">    Display</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">store</span>:store</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里没有什么好特别说明，就是一般我们在根组件中注入store，这样我们在每个组件中都可以访问。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上只实现了加一的功能，减一的功能类似，大家可以自己下来试试，如果觉得这个太容易，可以试一试这个<a href="https://segmentfault.com/a/1190000005015164#articleHeader5" target="_blank" rel="external">应用笔记项目</a>。</p>
<p>大年初二，23:30分。。。。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue学习之组件]]></title>
      <url>http://djl.pub/2017/01/21/Vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>组件在Vue中占有举足轻重的地位，在开发<em>高仿饿了么外卖APP</em>中也见识到了组件化开发的便捷和灵活。下面来总结一下。<br><a id="more"></a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://v1-cn.vuejs.org/guide/components.html" target="_blank" rel="external">官方Vue组件文档</a><br><a href="http://www.cnblogs.com/keepfool/p/5625583.html" target="_blank" rel="external">Vue.js——60分钟组件快速入门（上篇）</a><br><a href="http://www.cnblogs.com/keepfool/p/5637834.html" target="_blank" rel="external">Vue.js——60分钟组件快速入门（下篇）</a></p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义</span></div><div class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 注册</span></div><div class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</div><div class="line"><span class="comment">// 创建根实例</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#example'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个组件是全局注册。</p>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>有时我们需要在一个父组件下面注册另一个子组件，而这个子组件只能被这个父组件使用，那么我们就需要使用局部注册。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Child = Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;)</div><div class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'...'</span>,</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    <span class="comment">// &lt;my-component&gt; 只能用在父组件模板内</span></div><div class="line">    <span class="string">'my-component'</span>: Child</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>可以看到就是在一个父组件中的<strong>components</strong>属性中添加子组件。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>在子组件中data属性值是一个匿名函数的返回值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> MyComponent = Vue.extend(&#123;</div><div class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果不这样，那么每个实例都将共享这一个data，就会造成混乱。</p>
<ol>
<li>我们在子组件模板时，既可以以下面这种方式指定</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>但是我们更推荐使用H5的template标签来做，尤其是在子组件模板比较大的时候<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmpl"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>这是一个组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> component = Vue.extend(&#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">"#tmpl"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当然对子组件模板也有一些要求，不然会解析出错</p>
<blockquote>
<ul>
<li>a 不能包含其它的交互元素（如按钮，链接）</li>
<li>ul 和 ol 只能直接包含 li</li>
<li>select 只能包含 option 和 optgroup</li>
<li>table 只能直接包含 thead, tbody, tfoot, tr, caption, col,   colgroup</li>
<li>tr 只能直接包含 th 和 td </li>
</ul>
</blockquote>
<p> <a href="http://v1-cn.vuejs.org/guide/components.html#模板解析" target="_blank" rel="external">更多模板注意事项</a></p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>组件使用中最难的就是解决通信问题。一般有一下几种方式和情况</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>第一种就是在子组件中利用props属性，来实现父子组件中的通信。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tmlp-a</span> <span class="attr">:props-num</span>=<span class="string">"num"</span>&gt;</span><span class="tag">&lt;/<span class="name">tmlp-a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmlp-a"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;propsNum&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'tmlp-a'</span>,&#123;</div><div class="line">    <span class="attr">template</span>:<span class="string">"#tmlp-a"</span>,</div><div class="line">    <span class="attr">props</span>:[<span class="string">'propsNum'</span>],</div><div class="line">    <span class="attr">methods</span>:&#123;</div><div class="line">        <span class="attr">add</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.propsNum++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>:<span class="string">"#wrap"</span>,</div><div class="line">    <span class="attr">data</span>:&#123;</div><div class="line">        <span class="attr">num</span>:<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>通过props这个属性我们就可以拿到父组件的data数据，然后我们就可以操作这个数据，但是这里是一个单项问题，即我们在子组件中操作这个数据，并不会影响父组件中对应的数据，当然有一个办法就是通过props传递过来的是一个引用类型数据而不是一个基本变量，但是这无疑很麻烦。那么Vue提供了另外一种方法，那就是通过<strong>.sync</strong>修饰符来做。把代码做一点修改即可：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tmlp-a</span> <span class="attr">:props-num.sync</span>=<span class="string">"num"</span>&gt;</span><span class="tag">&lt;/<span class="name">tmlp-a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="Vue-dispatch"><a href="#Vue-dispatch" class="headerlink" title="Vue.$dispatch"></a>Vue.$dispatch</h3><p>第二种方式就是使用Vue.$dispatch（事件配发）来做，这种用法主要用在两个平级的子组件之间，它们有共同的父组件。也就是来解决兄弟组件间的通信问题，因为在一般情况下是不直接通信的（为了组件的独立性），那么有时候我们又有这样的需求。首先来看看通信的流程图：</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-21/79403842-file_1485003651843_8299.jpg" alt="dispatch原理图"></p>
<p>上面的通信方式，就如下面的对话。</p>
<blockquote>
<p>大儿子小明：老爸，让弟弟帮我拿一下快递，快递号码为（3737） //派发事件并传递参数3737<br>老爸听到了大儿子的请求，并开始行动 //父组件事件响应函数做出响应<br>老爸跑去找小儿子小明 //v-ref指令找到另一个子组件<br>爸爸：小华，快去拿一个快递，快递号码为（3737）<br>小儿子小明腾腾腾就去拿快递，告诉别人快递号码。</p>
</blockquote>
<p>代码示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">child-a</span> &gt;</span><span class="tag">&lt;/<span class="name">child-a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">child-b</span>  <span class="attr">v-ref:other-child</span>&gt;</span><span class="tag">&lt;/<span class="name">child-b</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"child-a"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"sendMsg"</span>&gt;</span>发送信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"child-b"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;receiveMsg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'#container'</span>,</div><div class="line">    <span class="attr">components</span>: &#123;</div><div class="line">        <span class="string">'childA'</span>: &#123;</div><div class="line">            <span class="attr">template</span>: <span class="string">'#child-a'</span>,</div><div class="line">            <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> &#123;</div><div class="line">                    <span class="attr">msg</span>:<span class="string">'DJL箫氏'</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">methods</span>: &#123;</div><div class="line">                <span class="attr">sendMsg</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">this</span>.$dispatch(<span class="string">'fatherTodo'</span>,<span class="keyword">this</span>.msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">'childB'</span>: &#123;</div><div class="line">            <span class="attr">template</span>: <span class="string">'#child-b'</span>,</div><div class="line">            <span class="attr">data</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">              <span class="keyword">return</span> &#123;</div><div class="line">                  <span class="attr">receiveMsg</span>:<span class="string">''</span></div><div class="line">              &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">methods</span>: &#123;</div><div class="line">                <span class="attr">receiveMsgFromA</span>: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">                    <span class="keyword">this</span>.receiveMsg = msg;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">'我接受到来自A的数据：'</span>+msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">events</span>: &#123;</div><div class="line">        <span class="attr">fatherTodo</span>: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.$refs.childB.receiveMsgFromA(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样就可以在兄弟组件实现通信</p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>最后一种方式就是利用<a href="https://github.com/vuejs/vuex/tree/1.0/docs/zh-cn" target="_blank" rel="external">Vuex</a>,关于这种方法，我会专门花一篇来写，敬请期待。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue学习之生命周期]]></title>
      <url>http://djl.pub/2017/01/21/Vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>生命周期在组件开发总非常重要，尤其是能在适当的时机取得数据,做一些初始化准备。下面我们来简单的聊聊Vue生命周期。<br><a id="more"></a><br>这里首先来看看Vue官方文档给出的生命周期示意图。</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-21/75404643-file_1484986273994_1820a.png" alt="Vue生命周期"></p>
<p>在这里我主要讨论init、created、beforeCompile、compiled、ready、beforeDestroy、destroyed这几个生命周期钩子函数。</p>
<p>init：在实例开始初始化时同步调用。此时数据观测、事件和 watcher 都尚未初始化。也是说在这里this.$el和this.$data都是拿不到的。</p>
<p>created:在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定，计算属性，方法，watcher/事件回调。但是还没有开始 DOM 编译，$el还不存在。也就是在这里已经可以访问this.$data了了。但是此时还没有进行模板编译。</p>
<p>beforeCompile：编译模板前，$el已经存在了。</p>
<p>compiled：模板编译完成，此时Vue指令已经生效，但是不能保证此时已经插入到文档中。</p>
<p>ready：在编译结束后和$el第一次插入到文档中的时候。这时可以从整个文档中获取到模板中的元素。</p>
<p>beforeDestroy：在销毁实例时调用，所有功能都还保持。</p>
<p>destroyed：在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，所有的子实例也已经被销毁。如果有离开过渡，destroyed 钩子在过渡完成之后调用。与挂载元素解除绑定</p>
<p>代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'-----init----'</span>)</div><div class="line">    <span class="comment">//  也就是说在这里$el获取不到，数据观测也没有建立，事件绑定等等都没有完成  实例初始化时同步调用</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里$el依然获取不到，但是数据观测已经建立，也就是说可以获得数据了，但是依然没有开始编译，也就是说Vue</span></div><div class="line">    <span class="comment">// 的一些指令是不起作用的</span></div><div class="line">    <span class="comment">// 实例创建后同步调用</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'----created---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">beforeCompile</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---beforeCompile---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">compiled</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---compiled---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="comment">// 此时指令已经生效，但是不确保插入到文档中</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">ready</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---ready---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="comment">// 在编译结束后和$el第一次插入到文档中的时候</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))  <span class="comment">//这时可以从整个文档中获取到模板中的元素</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'--在ready钩子函数中销毁实例--'</span>)</div><div class="line">    <span class="keyword">this</span>.$destroy(<span class="literal">true</span>);</div><div class="line">&#125;,</div><div class="line"><span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 在销毁实例时调用，所有功能都还保持</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---beforeDestroy---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">destroyed</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，所有的子实例也已经被销毁。</span></div><div class="line">    <span class="comment">// 与挂载元素解除绑定</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---destroyed---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-21/56048235-file_1484985260986_9fc2.jpg" alt="结果"></p>
<p>生命周期在组件开发总非常重要，尤其是能在适当的时机取得数据。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js学习]]></title>
      <url>http://djl.pub/2017/01/17/Vue-js%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>最近在慕课网上面买了一套<a href="http://coding.imooc.com/class/74.html" target="_blank" rel="external">高仿饿了么APP</a>视频,个人认为<br>对于我这种没有实际经验（还没有正式工作），又在学习Vue.js的人来说，绝对是非常值得的（不是打广告）。<br>而这套课程中主要用到了<strong>Vue</strong>、<strong>Vue-router</strong>、<strong>Vue-source</strong>、<strong>webpack</strong>、<strong>ES6</strong>、<strong>ESLint</strong>等等<br>所以通过这次课程我对于这些都有了一个大致了解。而这篇文章主要讲解Vue的1.0版本。我将会接下来的时间利用Vue2.0来实现一遍。<br><a id="more"></a></p>
<p><a href="http://v1-cn.vuejs.org/guide/" target="_blank" rel="external">官方文档</a></p>
<p>Vue.js的两大特性：组件化开发、数据驱动。之前没有学习任何框架的时候，开发过一个H5的音乐播放器，里面涉及<br>了大量DOM操作，实在很费神，如果使用Vue来做的话应该简单很多。由于Vue的官方文档已经写的比较好了而且又有中文版，<br>所以这里我并不打算讲Vue的一些基本知识（相比官方文档也讲不出什么花出来）</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h2 id="常见的用法"><a href="#常见的用法" class="headerlink" title="常见的用法"></a>常见的用法</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo初探---让写作飞起来]]></title>
      <url>http://djl.pub/2017/01/13/hexo%E5%88%9D%E6%8E%A2---%E8%AE%A9%E5%86%99%E4%BD%9C%E9%A3%9E%E8%B5%B7%E6%9D%A5/</url>
      <content type="html"><![CDATA[<p>这两天一直在捣鼓hexo，虽然不是很难，但是在搭建过程中，还是遇到了一些问题，导致花了两天。网上有很多相关教程，但是很多都含糊不清，其实让我豁然开朗的还是这篇文章，在此特别谢谢这位博主<a href="https://my.oschina.net/ryaneLee/blog/638440" target="_blank" rel="external">小白独立搭建博客–Github Pages和Hexo简明教程</a>。好了下面我们直接开始吧<br><a id="more"></a></p>
<h2 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h2><p><a href="https://git-scm.com/download" target="_blank" rel="external">Git</a>：版本控制器   </p>
<p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="external">Node</a>：提供服务器端JavaScript开发环境</p>
<p><a href="https://github.com" target="_blank" rel="external">GitHub</a>：需注册一个账号</p>
<p>在这里只提供下载链接，安装过程基本就是下一步了。</p>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1 安装hexo"></a>1 安装hexo</h3><p>安装好上述工具后，我们开始安装hexo，首先打开git,鼠标右键–&gt;git bash here</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-970cfcfc5c4d9e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Git_bash.png"></p>
<p>打开效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-f6d8b39d88552ff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开Git.png"></p>
<p>然后执行下面的命令<br><code>$ npm install -g hexo-cli</code>，全局安装hexo的脚手架，安装以后我们就可以全局使用hexo这个命令了。安装成功后执行下面命令<code>hexo -v</code>，就可以看见如下效果。<br><img src="http://upload-images.jianshu.io/upload_images/1948637-f6c1ceeafe9de1d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hexo安装成功.png"></p>
<p>接着执行下面命令<code>npm install hexo --save</code></p>
<p>然后新建一个文件夹比如hexo，在该文件夹下打开Git(即Git bash here)，执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo init </div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>不出问题的话，该文件夹下面会新增这些文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-a9604272a538c58f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hexo_init.png"></p>
<h3 id="3-安装hexo服务器"><a href="#3-安装hexo服务器" class="headerlink" title="3 安装hexo服务器"></a>3 安装hexo服务器</h3><p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 <a href="https://github.com/hexojs/hexo-server" target="_blank" rel="external">hexo-server</a> 才能使用。执行命令<code>$ npm install hexo-server --save</code>。这样安装好hexo服务器以后，我们就可以启动服务器了。执行命令<code>$ hexo server</code>，然后在浏览器输入网址<strong><a href="http://127.0.0.1:4000/" target="_blank" rel="external">http://127.0.0.1:4000/</a></strong>,就可以正常访问了。效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-762b47f41c85b29e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地效果.png">。</p>
<p>OK！现在本地已经没问题了，接下来就是要把它部署到远程服务器上了。</p>
<h3 id="3-建立GitHub-pages"><a href="#3-建立GitHub-pages" class="headerlink" title="3  建立GitHub pages"></a>3  建立GitHub pages</h3><p>新建一个github仓库</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-e9ad42417d0f33d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new_repository.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-ac753802c8884e86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitHub_pages建立.png"></p>
<p>这个仓库比较特殊，它要按照如下格式进行命名：你的GitHub用户昵称.github.io。新建好这个仓库后，见如下效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-82a49dd72ededad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="djlxs.github.io.png"></p>
<p>然后点击settings选项，向下翻到Git Pages选项</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-84fbadde099f3129.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入主题前Git_pages.png"></p>
<p>上面有一个提示信息</p>
<blockquote>
<p>GitHub Pages is currently disabled. You must first add content to your repository before you can publish a GitHub Pages site</p>
</blockquote>
<p>我们此时访问<a href="https://djlxs.github.io/" target="_blank" rel="external">https://djlxs.github.io/</a> 是会报404的，因为没有内容，我们可以点击下面的Choose a theme按钮，选择一个主题后，在访问<a href="https://djlxs.github.io/" target="_blank" rel="external">https://djlxs.github.io/</a> ，就可以了。此时看看GitHub Pages选项已经变成</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-ef566fc26d0cedcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择主题后.png"><br>上面有个提示信息</p>
<blockquote>
<p>Your GitHub Pages site is currently being built from the master<br> branch</p>
</blockquote>
<p>OK啦</p>
<h3 id="4-配置SSH公钥"><a href="#4-配置SSH公钥" class="headerlink" title="4 配置SSH公钥"></a>4 配置SSH公钥</h3><p>配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下：</p>
<p>第一步、看看是否存在SSH密钥(keys)<br>首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/. ssh</div></pre></td></tr></table></figure>
<p>检查你本机用户home目录下是否存在.ssh目录<br>如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。</p>
<p>第二步、创建一对新的SSH密钥(keys)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #这将按照你提供的邮箱地址，创建一对密钥</div></pre></td></tr></table></figure>
<p>直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如<code>/c/Users/you/.ssh/github_rsa</code><br>接着，根据提示，你需要输入密码和确认密码,在这里我们直接enter，不用输入密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</div><div class="line">Enter same passphrase again: [Type passphrase again]</div></pre></td></tr></table></figure>
<p>输入完成之后，屏幕会显示如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key </div><div class="line">has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint </div><div class="line">is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</div></pre></td></tr></table></figure>
<p>第三步、在GitHub账户中添加你的公钥<br>运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clip &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>
<p>接着：<br>登陆GitHub,进入你的Account Settings.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-2a9b043895299590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add_SSH_key.png"></p>
<p>第四步、测试<br>可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>成功后你会看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi djlxs! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>
<p>第五步、设置用户信息<br>现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;djlxs&quot;//用户名</div><div class="line">$ git config --global user.email &quot;djlxs@gmail.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure>
<h3 id="5-将本地文件同步至GitHub"><a href="#5-将本地文件同步至GitHub" class="headerlink" title="5 将本地文件同步至GitHub"></a>5 将本地文件同步至GitHub</h3><p><img src="http://upload-images.jianshu.io/upload_images/1948637-badcf3287146813f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="clone_https.png"></p>
<p>到新建的仓库下面复制HTTPS地址，然后打开本地hexo文件夹下的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-53f92f31dd7c739c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_config.jpg"></p>
<p>填入以下信息：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-d7c3768113ba4bc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add_config.jpg"></p>
<p>然后在命令窗口执行下面命令,安装相关部署插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>安装完成后，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d -g</div></pre></td></tr></table></figure>
<p>此时会让你输入GitHub的账号和密码，输入后在浏览器中输入 <a href="https://djlxs.github.io/" target="_blank" rel="external">https://djlxs.github.io/</a> 应该就可以访问了。</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>首先去<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo皮肤网站</a>,选择一款进入它的GitHub地址然后将clone的文件移动到<strong>themes</strong>文件夹下。然后修改<strong>_config.yml</strong>文件中的theme为你所选择的主题的名称即可。然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>现在本地看看主题皮肤是否已经更换过来，然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d -g</div></pre></td></tr></table></figure>
<p>同步至GitHub，刷新即可</p>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>首先在万网上购买自己的域名，然后进入管理界面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-b4d8e0c05fc2fe50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名解析.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-6ffad7b818b55492.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名解析内容.jpg"></p>
<p>然后在source文件夹下建立一个CNAME文件(没有后缀名)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-db064d9b5ef4c125.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CNAME文件.jpg"><br>然后执行</p>
<p>CNAME:是提供别名解析，就是说可以从一个域名解析绑定到另一个域名。 例如：<code>http://djlxs.github.io</code>  解析绑定到 <code>http://djl.pub</code>。<br>其中主机记录<strong><em>www</em></strong>代表一个二级域名此时输入<code>http://www.djl.pub</code>是可以正常访问的。如果主机记录是<strong><em>@</em></strong>代表直接输入<code>http://djl.pub</code>是可以访问的<br>一般情况下这两种方式我们都会添加，所以你在浏览器地址栏中输入<code>http://djl.pub</code>和<code>http://www.djl.pub</code>跳到是同一个页面。</p>
<p>A:提供的是一种IP地址解析到你所买的域名的解析方式。例如：<code>151.101.24.133</code>  解析到 <code>djl.pub</code></p>
<p>在这里我用的是阿里云自带的DNS服务器，当然你也可以使用其他第三方DNS服务器。例如：<a href="https://www.dnspod.cn/" target="_blank" rel="external">dnspod</a>,添加解析记录的方式一样<br>但是这里要记得在你购买域名的网站上更改默认的DNS服务商，以下以万网（域名提供商）和dnspod（域名解析服务商）为例</p>
<p>首先进入控制台进入域名管理，找到相应域名点击<strong>管理</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-1dbf77201fec45d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名管理控制台.jpg"></p>
<p>点击修<strong>改DNS</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-ea78ba366c068ee3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改DNS服务器.jpg"></p>
<p>将以下内容复制粘贴进下图的内容框中保存，即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f1g1ns1.dnspod.net</div><div class="line">f1g1ns2.dnspod.net</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-baad0040dbc4dae9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更改DNS服务器.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d -g</div></pre></td></tr></table></figure>
<p>同步至GitHub即可，至此hexo博客搭建基本就大功告成。下面推荐一个工具<a href="https://github.com/nihgwu/hexo-hey" target="_blank" rel="external">hexo-hey</a></p>
<p><a href="https://my.oschina.net/ryaneLee/blog/638440" target="_blank" rel="external">小白独立搭建博客–Github Pages和Hexo简明教程</a></p>
<p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">hexo中文文档</a></p>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p><img src="http://upload-images.jianshu.io/upload_images/1948637-f354427a1d5932cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="问题01.jpg"></p>
<p>解决办法:<a href="https://segmentfault.com/q/1010000003734223" target="_blank" rel="external">参考链接</a>、<a href="https://github.com/hexojs/hexo/issues/1503" target="_blank" rel="external">参考链接</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果你只是想搭建一个自己的博客，绑定自己的域名写写文章，不想自己动手添加其他功能（评论、分享、搜索），那么选择<br>一款好的皮肤就很重要，因为有的皮肤早已经帮你集成好了，只需要动手简单的改改配置文件就行，在这里给大家推荐一款皮肤<br>可能样式有些过于花哨，不过这些都可以自己调，功能很全，文档也比较全。<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">github地址</a></p>
<p>这是我在新的博客上面的第一篇文章，欢迎大家访问我的博客。<a href="http://djl.pub/">DJL箫氏</a></p>
]]></content>
    </entry>
    
  
  
</search>
