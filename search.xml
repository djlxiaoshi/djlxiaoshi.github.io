<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[exports和module.exports的区别]]></title>
      <url>http://djl.pub/2017/07/06/exports%E5%92%8Cmodule-exports%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>之前一直比较困惑exports和module.exports有什么区别。这里做一个比较详细的解释<br><a id="more"></a></p>
<p>首先我们来看一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"></div><div class="line">b.name = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = &#123;<span class="attr">name</span>: <span class="number">3</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"></div><div class="line">运行 test.js 结果为：</div><div class="line"></div><div class="line">&#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">3</span> &#125;</div></pre></td></tr></table></figure>
<p><strong>解释</strong> ：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。</p>
<p>明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：</p>
<ul>
<li><p><code>module.exports</code> 初始值为一个空对象 {}</p>
</li>
<li><p><code>exports</code> 是指向的 <code>module.exports</code> 的引用</p>
</li>
<li><p><code>require()</code> 返回的是 <code>module.exports</code> 而不是 <code>exports</code></p>
</li>
<li><p><code>exports.xxx</code>，相当于在导出对象上挂属性，该属性对调用模块直接可见</p>
</li>
<li><p><code>exports =</code> 相当于给exports对象重新赋值，调用模块不能访问exports对象及其属性,因为require返回的是<code>module.exports</code></p>
</li>
<li><p>如果此模块是一个类，就应该直接赋值module.exports，这样调用者就是一个类构造器，可以直接new实例；如果要导出一个模块实例，那么就直接挂在exports上</p>
</li>
<li><p>如果module.exports已经存在(即使是module.exports = {})，那么exports上面添加的任何属性都将被忽略</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="string">'ROCK IT!'</span>;</div><div class="line">exports.name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is Lemmy Kilmister'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rocker = <span class="built_in">require</span>(<span class="string">'./rocker.js'</span>);</div><div class="line">rocker.name(); <span class="comment">// TypeError: Object ROCK IT! has no method 'name'</span></div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html" target="_blank" rel="external">Node.js Module – exports vs module.exports</a></p>
<p><a href="https://github.com/chemdemo/chemdemo.github.io/issues/2" target="_blank" rel="external">Node.js module.exports与exports</a></p>
<p><a href="https://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="external">exports 和 module.exports 的区别</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[exports和module.exports的区别]]></title>
      <url>http://djl.pub/2017/07/06/exports%E5%92%8Cmodule.exports%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>之前一直比较困惑exports和module.exports有什么区别。这里做一个比较详细的解释<br><a id="more"></a></p>
<h1 id="exports和module-exports的区别"><a href="#exports和module-exports的区别" class="headerlink" title="exports和module.exports的区别"></a>exports和module.exports的区别</h1><p>首先我们来看一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"></div><div class="line">b.name = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = &#123;<span class="attr">name</span>: <span class="number">3</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"></div><div class="line">运行 test.js 结果为：</div><div class="line"></div><div class="line">&#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">2</span> &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="number">3</span> &#125;</div></pre></td></tr></table></figure></p>
<p><strong>解释</strong> ：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。</p>
<p>明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="string">'ROCK IT!'</span>;</div><div class="line">exports.name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is Lemmy Kilmister'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rocker = <span class="built_in">require</span>(<span class="string">'./rocker.js'</span>);</div><div class="line">rocker.name(); <span class="comment">// TypeError: Object ROCK IT! has no method 'name'</span></div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html" target="_blank" rel="external">Node.js Module – exports vs module.exports</a></p>
<p><a href="https://github.com/chemdemo/chemdemo.github.io/issues/2" target="_blank" rel="external">Node.js module.exports与exports</a></p>
<p><a href="https://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="external">exports 和 module.exports 的区别</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue2变化]]></title>
      <url>http://djl.pub/2017/05/01/Vue2%E5%8F%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>之前学习的是Vue1.0，这次项目开发使用的Vue2.0，其中有一些不同和新功能在这里记录一下。<a href="http://cn.vuejs.org/v2/guide/migration.html" target="_blank" rel="external">迁移文档</a><br><a id="more"></a></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a><a href="https://cn.vuejs.org/v2/guide/migration.html#过滤器" target="_blank" rel="external">过滤器</a></h2><p>1 Vue2 filter只能使用在双花括号中,在v-for等等指令中已经不能使用过滤器，转而使用计算属性和第三方库方法（也可以原声js写）例如：filterBy</p>
<p>2 现在Vue2已经移除了所有内置的过滤器，替代方案是使用第三方库（当然简单的也可以自己写一个）</p>
<p>3 参数形式改变，不再是使用空格来分隔参数而是<br><code>&lt;p&gt;\{\{ date \| formatDate(&#39;YY-MM-DD&#39;, timeZone) \}\}&lt;/p&gt;</code></p>
<p>当然如果你还是习惯Vue的那种内置过滤器，这里有一个比较好的filters库<a href="https://github.com/freearhey/vue2-filters" target="_blank" rel="external">vue2-filters</a>。</p>
<h2 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h2><p>组件通信，在Vue1.0中采用的是<code>$dispatch</code>和<code>$boradcast</code>,Vue2.0弃用了，同一使用了$emit，但是并没有使得兄弟组件之间的通信变得简单，对于简单的兄弟组件间的通信，我们可以通过创建一个空的Vue实例作为中央事件总线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</div><div class="line"><span class="comment">// 触发组件 A 中的事件</span></div><div class="line">bus.$emit(<span class="string">'id-selected'</span>, <span class="number">1</span>)</div><div class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></div><div class="line">bus.$on(<span class="string">'id-selected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>对于夸层级的组件（不是父子组件而是爷孙组件）通信，$emit并不能直接像事件冒泡一样，被爷爷组件监听到，这里我们也可以建立一个空的Vue实例作为中央事件总线，来进行通信。例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将在各处使用该事件中心</span></div><div class="line"><span class="comment">// 组件通过它来通信</span></div><div class="line"><span class="keyword">var</span> eventHub = <span class="keyword">new</span> Vue()</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Son 孙子组件</span></div><div class="line"><span class="comment">// ...</span></div><div class="line">methods: &#123;</div><div class="line">  <span class="attr">addTodo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    eventHub.$emit(<span class="string">'add-todo'</span>, &#123; <span class="attr">text</span>: <span class="keyword">this</span>.newTodoText &#125;)</div><div class="line">    <span class="keyword">this</span>.newTodoText = <span class="string">''</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 爷爷组件</span></div><div class="line">created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  eventHub.$on(<span class="string">'add-todo'</span>, <span class="keyword">this</span>.addTodo)</div><div class="line">  eventHub.$on(<span class="string">'delete-todo'</span>, <span class="keyword">this</span>.deleteTodo)</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>以上主要针对于简单的组件通信，当然如果情况变得更加复杂，还是推荐使用Vuex。</p>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>1 遍历对象时的参数顺序：原来是(key, value)，现在是 (value, key)<br>2 v-for=”number in 10” 的 number 从 0 开始到 9 结束，现在从 1 开始，到 10 结束。<br>3 track-by 已经替换为 key</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>1 现在只允许单项传递（父传子），如果子组件要改变props传递过来的值，并且使得父组件相应的得到改变，就必须利用$emit触发事件。当然还有一种情况就是子组件要求更改props传递过来的值，不需要父组件随之改变，这样貌似不会有什么影响，实际开发中也是一不小心就这样做了，但是这样是反模式的，更好的方式就是在data属性中建立一个字段dataA，然后props值来初始化这个dataA</p>
<p>2v-bind 的 .once和.sync 修饰符 </p>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>只能监听自定义事件，如果要监听根元素原生事件，添加.native修饰符<br><code>&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webpack引入插件的几种方法]]></title>
      <url>http://djl.pub/2017/05/01/webpack%E5%BC%95%E5%85%A5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>通常webpack引入插件有4中方式：<br>1 安装后直接在某个模块中运用<br>2 使用webpack plugins功能加载ProvidePlugin插件<br>3 expose-loader加载器加载<br>4 包装插件<br><a id="more"></a></p>
<h2 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h2><p>在需要使用的js文件中引入：<br><code>var  $  = require(&#39;jquery&#39;)</code>或者<code>import $ form &#39;jquery&#39;</code></p>
<h2 id="使用plugins"><a href="#使用plugins" class="headerlink" title="使用plugins"></a>使用plugins</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</div><div class="line">      <span class="attr">$</span>: <span class="string">"jquery"</span>,</div><div class="line">      <span class="attr">jQuery</span>: <span class="string">"jquery"</span></div><div class="line">    &#125;)</div><div class="line">]</div></pre></td></tr></table></figure>
<p>使用这种方式，就可以全局使用jQuery，但是对于使用了ESlint就会报错：<code>&#39;$&#39; is not defined</code></p>
<blockquote>
<p>ProvidePlugin: Automatically loaded modules. Module (value) is loaded when the identifier (key) is used as free variable in a module. The identifier is filled with the exports of the loaded module.</p>
</blockquote>
<p>也就是说jQuery模块只会在使用<code>$</code>的模块中加载，并不是真正的全局加载</p>
<h2 id="expose-loader"><a href="#expose-loader" class="headerlink" title="expose-loader"></a><a href="https://github.com/webpack-contrib/expose-loader" target="_blank" rel="external">expose-loader</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">test</span>: <span class="built_in">require</span>.resolve(<span class="string">'jquery'</span>),</div><div class="line">    <span class="attr">use</span>: [&#123;</div><div class="line">        <span class="attr">loader</span>: <span class="string">'expose-loader'</span>,</div><div class="line">        <span class="attr">options</span>: <span class="string">'$'</span></div><div class="line">    &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在任意模块中引入<code>require(&quot;expose-loader?$!jquery&quot;);</code></p>
<h2 id="包装jQuery"><a href="#包装jQuery" class="headerlink" title="包装jQuery"></a>包装jQuery</h2><p>vendor.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></div><div class="line"><span class="built_in">window</span>.$ = $</div><div class="line"><span class="built_in">window</span>.jQuery = $</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> $</div></pre></td></tr></table></figure></p>
<p>模块引入：<code>import $ from &#39;../assets/vendor.js&#39;</code><br>webpakck中设置别名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alias: &#123;</div><div class="line">    <span class="comment">//将其指向vendor.js所在位置</span></div><div class="line">    jquery : <span class="string">'src/assets/jquery-vendor.js'</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://blog.csdn.net/yiifaa/article/details/51916560" target="_blank" rel="external">参考文章</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[angular1学习之控制器通信]]></title>
      <url>http://djl.pub/2017/04/07/angular1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>指令与控制器之间通信，无非是以下几种方法：</p>
<ul>
<li>基于scope继承的方式</li>
<li>基于event传播的方式</li>
<li>service的方式<a id="more"></a>
</li>
</ul>
<h1 id="基于scope继承的方式"><a href="#基于scope继承的方式" class="headerlink" title="基于scope继承的方式"></a>基于scope继承的方式</h1><p>最简单的让控制器之间进行通信的方法是通过scope的继承。假设有两个控制器Parent、Child，Child 在 Parent 内，那Child 可以称为控制器Parent的子控制器，它将继承父控制器Parent的scope。这样，Child就可以访问到Parent的scope中的所有函数和变量了。</p>
<p>需要注意的是，由于scope的继承是基于Js的原型继承，如果变量是基本类型的，那在Child中的修改（写），有可能会导致Parent中的数据变脏。如下：</p>
<p>基本类型以及引用类型变量的继承</p>
<p>此<a href="http://jsbin.com/qezot/4/edit?html,js,output" target="_blank" rel="external">DEMO</a>代码中我们看到，两个_value，其中一个 _value 属性是直接被注册到\$scope 中，另一个 _value 是注册到 parent 控制的 $scope.obj 中，DEMO效果如下：</p>
<p>1 child能读取到parent中的_value值，所以默认页面 显示的是4个 default值</p>
<p>2 如果先改变了直接注册在child上 $scope 上的 _value 属性，则直接注册在 parent.$scope 的 _value 跟直接注册在 chile.$scope的_value失去了联系，页面上的表现：就是如果先点击了child的按钮，点击parent的按钮 child.$scope 上的 _value 则不会变化。</p>
<p>3 反过来，如果未对直接注册在 chile.$scope 的_value进行改写，则注册在 parent.$scope 的 _value 跟chile.$scope 的 _value还有联系，页面上表现跟以上相反。</p>
<p>4 而注册在 obj 上的 _value 属性，则一直是有联系的。</p>
<p>经过以上实验，我们得出一下结论：</p>
<blockquote>
<p><strong>子级scope改写的属性不要直接注册在$scope对象上，而应该尽可能注册在$scope上的引用类型上，以免污染$scope。</strong></p>
</blockquote>
<h1 id="基于event传播的方式"><a href="#基于event传播的方式" class="headerlink" title="基于event传播的方式"></a>基于event传播的方式</h1><p>通过 scope 继承 能处理父子级控制器之间的通信问题，但是不能处理兄弟/相邻控制器之间的通信问题。而基于 event 传递的方式进行通信可以解决父子级的通信问题。angular提供了三个方法：$on , $emit , $broadcast</p>
<h2 id="子–-gt-父：-emit"><a href="#子–-gt-父：-emit" class="headerlink" title="子–&gt;父：$emit"></a>子–&gt;父：$emit</h2><p>event传播过程是这样的：</p>
<p>子scope中的控制器通过 $scope.$emit注册一个向上传播的事件,该事件会经过每一层的父scope，但是每一层父scope不会去处理,如果要处理就在想要处理的父scope中使用$scope.$on监听<a href="http://jsbin.com/goxiw/5/edit?html,js,output" target="_blank" rel="external">DEMO</a>。跟JS中的DOM事件一样，如果你不想让你的事件再往更上层传播，在$on中的处理函数调用e.stopPropagation()即可。</p>
<h2 id="父–-gt-子：-broadcast"><a href="#父–-gt-子：-broadcast" class="headerlink" title="父–&gt;子：$broadcast"></a>父–&gt;子：$broadcast</h2><p>从父到子，跟子集到父级一样，使用同样用$broadcast注册时间，用 $on 监听着，<a href="http://jsbin.com/gidomu/10/edit?html,js,output" target="_blank" rel="external">DEMO</a>。</p>
<h2 id="同级之间"><a href="#同级之间" class="headerlink" title="同级之间"></a>同级之间</h2><p>拥有同个父scope的子级scope之间，也就是兄弟/相邻scope之间的通信，其实是借助共同父级传递消息的：</p>
<p>子级scope中有谁想传消息了，$emit一个给“奶爸”,然后通过“奶爸”$broadcast给所有孩子这个相同的信息，当然发出信息的那个可以选择是否要忽略掉自己发出的信息</p>
<h1 id="angular服务的方式"><a href="#angular服务的方式" class="headerlink" title="angular服务的方式"></a>angular服务的方式</h1><p>在angular中服务是一个单例，在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。参照以下例子，在一个控制器修改了服务对象的值，在另一个相邻控制器中获取到修改后的值：</p>
<p><a href="http://jsbin.com/hopazo/5/edit?html,css,js,output" target="_blank" rel="external">DEMO</a></p>
<p><strong>特别注明：此文为转载，原文链接 <a href="http://www.html5jscss.com/angular-between-controller.html" target="_blank" rel="external">AngularJs开发——控制器间的通信</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[angular1学习之directive]]></title>
      <url>http://djl.pub/2017/04/06/angular1%E5%AD%A6%E4%B9%A0%E4%B9%8Bdirective/</url>
      <content type="html"><![CDATA[<p>作为只学过Vue的前端来说，angular的概念还真是比较多的，但是每接触一个概念我都会和Vue相关概念做一个对比，这样的对比对我理解angular起了非常大的作用。这节主要讲解directive，类比Vue就好比Vue里面的组件。<br><a id="more"></a></p>
<h1 id="自定义一个指令"><a href="#自定义一个指令" class="headerlink" title="自定义一个指令"></a>自定义一个指令</h1><p>首先angular定义一个指令的方式如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'container'</span>,[])</div><div class="line">app.controller(<span class="string">'wrap'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">    $scope.nickName = <span class="string">'DJL箫氏'</span></div><div class="line">&#125;)</div><div class="line">app.directive(<span class="string">'myDirective'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'A'</span>,</div><div class="line">        <span class="attr">template</span> : <span class="string">'&lt;h1&gt;自定义指令&#123;&#123;nickName&#125;&#125;&lt;/h1&gt;'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我们通过app.directive方法来创建指令，指令名称遵从驼峰命名规则，在使用的时候用<code>-</code>分开<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>作为刚学angular的人来说，为什么有时候使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'wrap'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">    $scope.nickName = <span class="string">'DJL箫氏'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>有时候<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'wrap'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">    $scope.nickName = <span class="string">'DJL箫氏'</span></div><div class="line">&#125;])</div></pre></td></tr></table></figure></p>
<p>如果服务名和function中的参数名一致，则可以不写成数组的形式，如果要更换名字则写成数组的形式。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'wrap'</span>, [<span class="string">'$scope'</span>,<span class="string">'myService'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    $scope.nickName = <span class="string">'DJL箫氏'</span></div><div class="line">&#125;])</div></pre></td></tr></table></figure></p>
<p>那么a即<code>$scope</code>服务，b即<code>myService</code>服务</p>
<h1 id="常用属性介绍"><a href="#常用属性介绍" class="headerlink" title="常用属性介绍"></a>常用属性介绍</h1><h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>自定义指令会返回一个对象，里面有很多属性<code>restrict:A</code>属性表示在html代码中调用这个属性只能通过属性的形式来调用，当然值还有E（只能通过标签元素的方式调用）,C(只能通过class的方式调用)，EAC（以上三种方式都可以）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="name">my-directive</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-directive"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="template-amp-templateUrl"><a href="#template-amp-templateUrl" class="headerlink" title="template &amp; templateUrl"></a>template &amp; templateUrl</h2><p>template属性则是这个指令的DOM结构，也就是说指令适用于与DOM有关的场景。我们可以看到在指令中可以拿到包含它的controller中的数据（$scope）。当然如果指令的DOM结构非常复杂，这个时候我们可以使用templateUrl属性来替代template属性，templateUrl的值为dom模板的地址。当然我们可以使用<code>ng-template</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/ng-template&quot; id=&quot;part.html&quot;&gt;</div><div class="line">    &lt;h1&gt;通过ng-template封装的part.html&lt;/h1&gt;</div><div class="line">    &lt;p&gt;这里是part.html中的内容&lt;/p&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">templateUrl: <span class="string">'part.html'</span></div></pre></td></tr></table></figure>
<h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>该属性表明这个指令是直接插入到DOM结构中（值为TRUE），还是先把<code>&lt;my-directive&gt;&lt;/my-directive&gt;</code>这个标签去除后只插入指令中template或者templateUrl中的内容。<br><img src="http://ok3x4ia9b.bkt.clouddn.com/17-4-6/52136146-file_1491473056558_dddc.png" alt="值为false"><br><img src="http://ok3x4ia9b.bkt.clouddn.com/17-4-6/30517686-file_1491472930303_7e1e.png" alt="值为true"></p>
<h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><p>在前面我们知道directive可以直接拿到所在controller中的数据，但是如果在同一个controller中有多个directive，我们希望通过传入directive不同的值来展示不同的结果，这时我们就要使用scope属性，这个属性类似于Vue组件中props属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-directive</span> <span class="attr">user</span>=<span class="string">"userA"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-directive</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">scope:&#123;</div><div class="line">    <span class="attr">user</span>: <span class="string">"="</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">template</span> : <span class="string">"&lt;p&gt;姓名:&#123;&#123;user.name&#125;&#125;&lt;/p&gt;&lt;p&gt;性别：&#123;&#123;user.sex&#125;&#125;&lt;/p&gt;"</span></div><div class="line"></div><div class="line">App.controller(<span class="string">"wrap"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">    $scope.userA = &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">"DJL箫氏"</span>,</div><div class="line">        <span class="attr">sex</span> : <span class="string">"男"</span></div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这里<code>user: &#39;=&#39;</code>,其中‘=’表示传入一个引用值（如果在directive中改变数据，controller中的数据也会跟随改变），当然值还可以是‘@’（传入一个字符串，那么此时传入的就是userA这个字符串了），&amp;（传入一个回调函数）</p>
<h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p>link属性就类似于Vue里面的生命周期钩子函数，是会自动执行的，所以可以把一些初始化任务放在里面。link函数有3个参数scope（暂时理解为directive中scope属性）,element（指令中template对应的DOM）,attrs。</p>
<p>由于Angular几乎照搬了jQuery的DOM操作源码，所以我们在操作DOM时，可以基本舒勇jQuery的语法，当然如果我们要使用jQuery来操作也非常简单，我们只需要安装jQuery然后在index.html中引入jQuery（注意顺序）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 保证在angular.js之前引入jquery.js --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"components/jquery/dist/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"components/angular/angular.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h2 id="transclude"><a href="#transclude" class="headerlink" title="transclude"></a>transclude</h2><p>有时候我们想在指令中添加一些自定义的元素，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-directive</span> <span class="attr">user</span>=<span class="string">"userA"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-directive</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这时我们就需要设置transclude属性值为true。<br>同时在指令的DOM结构合适的位置中加入<code>&lt;ng-transclude&gt;&lt;/ng-transclude&gt;</code>或者以属性的方式<code>&lt;div ng-transclude&gt;&lt;/div&gt;</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template : <span class="string">'&lt;h1&gt;自定义指令&lt;ng-transclude&gt;&lt;/ng-transclude&gt;&lt;/h1&gt;'</span></div></pre></td></tr></table></figure></p>
<p>所以我们会发现ng-app这些指令的transclude属性都设置成了true</p>
<p>ok 目前常用的就是这些，下节会讲directive之间的通信问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript模块加载 - AMD]]></title>
      <url>http://djl.pub/2017/04/04/JavaScript%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%20-%20AMD/</url>
      <content type="html"><![CDATA[<p>随着js代码的增加，将所有的js代码放在一个js文件里面，会使得这个js代码非常臃肿，所以我们需要把js代码模块化。于是我们会按如下方法来做：<br><a id="more"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"a.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"b.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"c.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"d.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这样做有两个缺陷：1 随着js文件的增多，加载js文件会阻塞浏览器的渲染；2 这些js文件之间可能存在严格的依赖关系，导致js文件的加载必须遵从顺序。</p>
<p>为了解决这个问题，JavaScript引入了模块的概念，目前分为浏览器端和服务器端。浏览器端模块加载规范一般有AMD（异步加载js文件）和CMD（同步加载js文件），服务器端就是common.js规范。而一般情况下，浏览器端更适合使用异步加载，因为在浏览器端，js文件的加载取决于网络状况，采用异步加载，可以避免因为网络问题带来的浏览器阻塞问题。在这里将简单介绍<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>,AMD规范的一种实现方式。</p>
<h1 id="引入require-js"><a href="#引入require-js" class="headerlink" title="引入require.js"></a>引入require.js</h1><p>首先我们在页面中引入require.js，并且设置data-main属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>其中data-main属性指定所有js文件的一个入口。为了在引入require.js的时候不阻塞浏览器的渲染，我们可以将<code>script</code>标签放在body底部，当然也可以利用script异步加载属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"js/require.js"</span> defer <span class="keyword">async</span>=<span class="string">"true"</span> &gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><code>defer</code>是为了兼容IE</p>
<h1 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h1><p>现在我们就可以在main.js入口文件中书写自己的js代码了，一般情况下入口文件会依赖很多其他模块，那么我们在使用时需要引入这些模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    alert(a.add(<span class="number">1</span>,<span class="number">2</span>))   <span class="comment">// 3</span></div><div class="line">    alert(b.dec(<span class="number">1</span>,<span class="number">2</span>))   <span class="comment">// -1</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>根据AMD规范引入模块的写法，我们在main.js这个模块中引入了a.js和b.js这两个模块。这两个模块和main.js在同一个目录之下，但是如果不在一个目录中，那么我们就需要通过require.config定义模块路径：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="string">'a'</span>: <span class="string">'test/a'</span>,</div><div class="line">        <span class="string">'b'</span>: <span class="string">'test/b'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.alert(a.add(<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">    <span class="built_in">window</span>.alert(b.dec(<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>require.config要放在main.js的头部。当然也可以改变js文件路径的基目录<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>:<span class="string">'js/lib'</span>,</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="string">'a'</span>: <span class="string">'a'</span>,</div><div class="line">        <span class="string">'b'</span>: <span class="string">'b'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.alert(a.add(<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">    <span class="built_in">window</span>.alert(b.dec(<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h1 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h1><p>根据AMD规范，我们定义模块要是<code>define</code>。例如a.js</p>
<h2 id="定义键值对"><a href="#定义键值对" class="headerlink" title="定义键值对"></a>定义键值对</h2><p>如果一个模块不依赖于其他模块并且只是一些键值对的容器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(&#123;</div><div class="line">    <span class="attr">color</span>: <span class="string">"black"</span>,</div><div class="line">    <span class="attr">size</span>: <span class="string">"unisize"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>如果一个模块不依赖于其他模块，但是又要做一些设置工作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//Do setup work here</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">color</span>: <span class="string">"black"</span>,</div><div class="line">        <span class="attr">size</span>: <span class="string">"unisize"</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="定义有依赖的函数"><a href="#定义有依赖的函数" class="headerlink" title="定义有依赖的函数"></a>定义有依赖的函数</h2><p>一般情况下，一个模块都会依赖一个或者多个其他模块，在定义这些模块时，我们要首先引入它所依赖的模块。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">"a"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">       <span class="attr">result</span> : a.add(<span class="number">1</span> + <span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="加载不符合AMD规范的模块"><a href="#加载不符合AMD规范的模块" class="headerlink" title="加载不符合AMD规范的模块"></a>加载不符合AMD规范的模块</h1><p>有一些模块是不符合AMD规范的，我们在使用的时候，要进行如下配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">　　<span class="attr">shim</span>: &#123;</div><div class="line">　　　<span class="string">'underscore'</span>:&#123;</div><div class="line">　　　　　<span class="attr">exports</span>: <span class="string">'_'</span></div><div class="line">　　　 &#125;,</div><div class="line">　　   <span class="string">'backbone'</span>: &#123;</div><div class="line">　　　　　　<span class="attr">deps</span>: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</div><div class="line">　　　　　　<span class="attr">exports</span>: <span class="string">'Backbone'</span></div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>即要在shim属性中定义这个模块导出后的变量名和依赖。</p>
<p>以上介绍的是require.js的最基本用法，当然目前也就用到了这么多。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">Javascript模块化编程（三）：require.js的用法</a><br><a href="http://requirejs.org/" target="_blank" rel="external">require.js</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NODE使用小插件]]></title>
      <url>http://djl.pub/2017/03/25/NODE%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>本文专门用来搜集一些平时开发中可能用到的小插件，持续更新中。。。。。。<br><a id="more"></a></p>
<p><a href="https://github.com/JacksonTian/anywhere" target="_blank" rel="external">anywhere</a>  随启随用的静态文件服务器</p>
<p> <a href="https://www.npmjs.com/package/npm-run-all" target="_blank" rel="external">npm-run-all</a>  同时运行多个不退出js程序</p>
<p><a href="https://www.npmjs.com/package/serve-favicon" target="_blank" rel="external">serve-favicon</a>  设置浏览器标签页图标</p>
<p>逐步更新中。。。。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CORS跨域]]></title>
      <url>http://djl.pub/2017/03/25/CORS%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p>当访问其他域名或者同一域名不同端口上的资源时，就会产生跨域请求。而跨域请求确实是发起了，但是返回的结果却被浏览器拦截了，请求必须遵循的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">同源策略</a>。但是在工作中不可避免的会进行跨域访问。现在用的最多的就是Jsonp和cors但是jsonp只能发起get请求，而且携带数据量较小，如果要发起post请求，那么就要采用cors方案。<br><a id="more"></a></p>
<h2 id="允许跨域场景"><a href="#允许跨域场景" class="headerlink" title="允许跨域场景"></a>允许跨域场景</h2><p>跨源资源共享标准( cross-origin sharing standard ) 允许以下场景可以发起跨站 HTTP 请求：</p>
<ul>
<li>使用 XMLHttpRequest 或 Fetch发起跨站 HTTP 请求。</li>
<li>Web 字体 (CSS 中通过 @font-face使用跨站字体资源)</li>
<li>WebGL 贴图</li>
<li>使用drawImage 将 Images/video 画面绘制到canvas.</li>
<li>样式表（使用 CSSOM）</li>
<li>Scripts (未处理的异常)</li>
</ul>
<p>cors通过增加一些HTTP头，让服务器声明哪些源可以通过浏览器访问该服务器上的资源。其实也就是设置’Access-Control-Allow-Origin’,’*‘这个响应头，当然这里是允许所有来源，我们也可以具体指定。注意设置了credentials = true,就不能设置’Access-Control-Allow-Origin’, ‘*’,会报错。</p>
<h2 id="预请求"><a href="#预请求" class="headerlink" title="预请求"></a>预请求</h2><p>一般发起的跨域请求都会先发送预请求，服务器允许后，浏览器才会以真正的HTTP请求方式发送请求，这是出于服务器的安全。那么如果同时满足一下几种情况是不会发送预请求（请求方式为OPTIONS，这是HTTP1.1中新增的方式）的。</p>
<h3 id="请求方式必须是GET、POST、HEAD"><a href="#请求方式必须是GET、POST、HEAD" class="headerlink" title="请求方式必须是GET、POST、HEAD"></a>请求方式必须是GET、POST、HEAD</h3><h3 id="请求头除了是用户代理自动设置（例如：Connection-User-Agent）和如下请求头"><a href="#请求头除了是用户代理自动设置（例如：Connection-User-Agent）和如下请求头" class="headerlink" title="请求头除了是用户代理自动设置（例如：Connection, User-Agent）和如下请求头"></a>请求头除了是用户代理自动设置（例如：Connection, User-Agent）和如下请求头</h3><ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type (but note the additional requirements below)</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
<h3 id="Content-type必须要是如下值"><a href="#Content-type必须要是如下值" class="headerlink" title="Content-type必须要是如下值"></a>Content-type必须要是如下值</h3><ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
<p><strong>注意上面三个条件必须是同时满足</strong></p>
<p>例如POST请求，但是如果Content-type:application/json那么就会发起预请求。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>域为<a href="http://foo.example向域为http://bar.other的发起请求" target="_blank" rel="external">http://foo.example向域为http://bar.other的发起请求</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"><span class="keyword">var</span> url = <span class="string">'http://bar.other/resources/public-data/'</span>;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(invocation) &#123;    </div><div class="line">    invocation.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">    invocation.onreadystatechange = handler;</div><div class="line">    invocation.send(); </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://mdn.mozillademos.org/files/14293/simple_req.png" alt="示意图"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GET /resources/public-data/ HTTP/1.1</div><div class="line">Host: bar.other</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: en-us,en;q=0.5</div><div class="line">Accept-Encoding: gzip,deflate</div><div class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class="line">Connection: keep-alive</div><div class="line">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</div><div class="line">Origin: http://foo.example</div><div class="line"></div><div class="line"></div><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 01 Dec 2008 00:23:53 GMT</div><div class="line">Server: Apache/2.0.61 </div><div class="line">Access-Control-Allow-Origin: *</div><div class="line">Keep-Alive: timeout=2, max=100</div><div class="line">Connection: Keep-Alive</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Content-Type: application/xml</div></pre></td></tr></table></figure>
<p>我们可以看到响应头中设置了<code>Access-Control-Allow-Origin: *</code>，那么此时是能够正常拿到数据的。</p>
<h2 id="携带cookies"><a href="#携带cookies" class="headerlink" title="携带cookies"></a>携带cookies</h2><p>一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"><span class="keyword">var</span> url = <span class="string">'http://bar.other/resources/credentialed-content/'</span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(invocation) &#123;</div><div class="line">    invocation.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">    invocation.withCredentials = <span class="literal">true</span>;</div><div class="line">    invocation.onreadystatechange = handler;</div><div class="line">    invocation.send(); </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里只是设置了一个标志位，并不是一个请求头，所以这是一个简单请求，是不会发送预请求的。但是在服务器端一定要设置<code>Access-Control-Allow-Credentials:true</code>,不然浏览器不会把服务器端的结果返回给发起请求的script脚本，浏览器会报错。</p>
<h2 id="发起跨域请求时，服务器返回的部分HTTP响应头"><a href="#发起跨域请求时，服务器返回的部分HTTP响应头" class="headerlink" title="发起跨域请求时，服务器返回的部分HTTP响应头"></a>发起跨域请求时，服务器返回的部分HTTP响应头</h2><ul>
<li>Access-Control-Allow-Origin    设置允许的客户端代理。<strong>注意当设置值为*时，就不能在客户端设置withCredentials为TRUE</strong></li>
<li>Access-Control-Expose-Headers：设置浏览器可以的访问到的服务器头信息的白名单，如果设置，那么在浏览器端是可以看到服务器设置了哪些头信息。<blockquote>
<p>Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</p>
</blockquote>
</li>
<li>Access-Control-Max-Age：允许这个预请求可以缓存的时间，在设置时间内，将不再发送这个预请求</li>
<li>Access-Control-Allow-Credentials：设置服务器响应数据是否可以被<code>credentials</code>设置为TRUE的客户端拿到，如果为FALSE，那么响应数据客户端script脚本是拿不到的。</li>
<li>Access-Control-Allow-Methods：设置客户端发起请求的方式</li>
</ul>
<h2 id="HTTP-请求头"><a href="#HTTP-请求头" class="headerlink" title="HTTP 请求头"></a>HTTP 请求头</h2><ul>
<li>origin ：表明发起跨域请求的域</li>
<li>Access-Control-Request-Method ：这个是在发送预请求时，告诉服务器，真实请求的请求方式。</li>
<li>Access-Control-Request-Headers ：当发送预请求时，告诉服务器，发送真实请求时，所包含的请求头信息。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP access control (CORS)</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端跨域请求原理及实践]]></title>
      <url>http://djl.pub/2017/03/11/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="跨域请求的含义"><a href="#跨域请求的含义" class="headerlink" title="跨域请求的含义"></a>跨域请求的含义</h2><p>浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如JavaScript）对不同域的服务进行跨站调用。一般的，只要网站的 协议名protocol、主机host、端口号port这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。这也是我们下面实践的理论基础。我们利用NodeJs创建了两个服务器，分别监听3000、3001端口（下面简称服务器3000与服务器3001），由于端口号不一样，这两个服务器以及服务器上页面通信构成了跨域请求。在服务器3000 上有如下的页面：<br><a id="more"></a></p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3001_page.png" alt=""></p>
<p>服务器3000 上的请求页面中包含如下 JavaScript 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> data = &#123;</div><div class="line">            <span class="attr">name</span>: $(<span class="string">"#name"</span>).val(),</div><div class="line">            <span class="attr">id</span>: $(<span class="string">"#id"</span>).val()</div><div class="line">        &#125;;</div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">type</span>: <span class="string">'POST'</span>,</div><div class="line">            <span class="attr">data</span>: data,</div><div class="line">            <span class="attr">url</span>: <span class="string">'http://localhost:3000/ajax/deal'</span>,</div><div class="line">            <span class="attr">dataType</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">cache</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">timeout</span>: <span class="number">5000</span>,</div><div class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(data)</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'error '</span> + textStatus + <span class="string">' '</span> + errorThrown);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器3000 对应的处理函数为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.post(<span class="string">'/ajax/deal'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"server accept: "</span>, req.body.name, req.body.id)</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">        <span class="attr">name</span>: req.body.name + <span class="string">' - server 3000 process'</span>,</div><div class="line">        <span class="attr">id</span>: req.body.id + <span class="string">' - server 3000 process'</span></div><div class="line">    &#125;</div><div class="line">    res.send(data)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>请求页面返回结果：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3000.png" alt=""></p>
<p>此处数据处理成功。</p>
<p>由于数据请求一般都是由页面发送数据字段，服务器根据这些字段作相应的处理，如数据库查询，字符串操作等等。所以我们这里简单的处理数据（在数据后面加上字符串‘server3000process’），并且返回给浏览器，表示数据经过服务器端处理。如果让服务器3000上的页面向服务器3001发起请求会怎样呢？将请求页面中的ajax请求路径改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    ...</div><div class="line">    url: <span class="string">'http://localhost:3001/ajax/deal'</span>,</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器3001 对应的处理函数与 服务器3000 类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.post(<span class="string">'/ajax/deal'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"server accept: "</span>, req.body.name, req.body.id)</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">        <span class="attr">name</span>: req.body.name + <span class="string">' - server 3001 process'</span>,</div><div class="line">        <span class="attr">id</span>: req.body.id + <span class="string">' - server 3001 process'</span></div><div class="line">    &#125;</div><div class="line">    res.send(data)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3001_error.png" alt=""></p>
<p>结果证明了我们上面所说的端口号不同，发生了跨域请求的调用。需要注意的是，服务器 3001 控制台有输出：</p>
<blockquote>
<p>server accept:  chiaki 3001</p>
</blockquote>
<p>这说明跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。</p>
<h2 id="利用-JSONP-实现跨域调用"><a href="#利用-JSONP-实现跨域调用" class="headerlink" title="利用 JSONP 实现跨域调用"></a>利用 JSONP 实现跨域调用</h2><p>说道跨域调用，可能大家首先想到的或者听说过的就是 JSONP 了。</p>
<h3 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h3><blockquote>
<p>JSONP (JSON with Padding or JSON-P) is a JSON extension used by web developers to overcome the cross-domain restrictions imposed by browsers’ same-origin policy that limits access to resources retrieved from origins other than the one the page was served by. In layman’s terms, one website cannot just simply access the data from another website.<br>It was developed because handling a browsers’ same origin policy can be difficult, so using JSONP abstracts the difficulties and makes it easier.<br>JSON stands for “JavaScript Object Notation”, a format by which object fields are represented as key-value pairs which is used to represent data.</p>
</blockquote>
<p>JSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据XmlHttpRequest对象受到同源策略的影响，而script标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据,而是可以直接运行的 JavaScript 语句。</p>
<h3 id="使用-jQuery-集成的-ajax-实现-JSONP-跨域调用"><a href="#使用-jQuery-集成的-ajax-实现-JSONP-跨域调用" class="headerlink" title="使用 jQuery 集成的 $.ajax 实现 JSONP 跨域调用"></a>使用 jQuery 集成的 $.ajax 实现 JSONP 跨域调用</h3><p>我们先从简单的实现开始，利用jQuery中的$.ajax来实现上诉的跨域调用。依然是上面的例子，我们将服务器 3000 上的请求页面的 JavaScript 代码改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 回调函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"jsonpCallback: "</span> + data.name)</div><div class="line">&#125;</div><div class="line">$(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">        <span class="attr">name</span>: $(<span class="string">"#name"</span>).val(),</div><div class="line">        <span class="attr">id</span>: $(<span class="string">"#id"</span>).val()</div><div class="line">    &#125;;</div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://localhost:3001/ajax/deal'</span>,</div><div class="line">        <span class="attr">data</span>: data,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</div><div class="line">        <span class="attr">cache</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">timeout</span>: <span class="number">5000</span>,</div><div class="line">        <span class="comment">// jsonp 字段含义为服务器通过什么字段获取回调函数的名称</span></div><div class="line">        jsonp: <span class="string">'callback'</span>,</div><div class="line">        <span class="comment">// 声明本地回调函数的名称，jquery 默认随机生成一个函数名称</span></div><div class="line">        jsonpCallback: <span class="string">'jsonpCallback'</span>,</div><div class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"ajax success callback: "</span> + data.name)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(textStatus + <span class="string">' '</span> + errorThrown);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器 3001 上对应的处理函数为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/ajax/deal'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"server accept: "</span>, req.query.name, req.query.id)</div><div class="line">    <span class="keyword">var</span> data = <span class="string">"&#123;"</span> + <span class="string">"name:'"</span> + req.query.name + <span class="string">" - server 3001 process',"</span> + <span class="string">"id:'"</span> + req.query.id + <span class="string">" - server 3001 process'"</span> + <span class="string">"&#125;"</span></div><div class="line">    <span class="keyword">var</span> callback = req.query.callback</div><div class="line">    <span class="keyword">var</span> jsonp = callback + <span class="string">'('</span> + data + <span class="string">')'</span></div><div class="line">    <span class="built_in">console</span>.log(jsonp)</div><div class="line">    res.send(jsonp)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这里一定要注意 data 中字符串拼接，不能直接将 JSON 格式的data直接传给回调函数，否则会发生编译错误： <code>parsererror Error: jsonpCallback was not called。</code></p>
<p><strong><em>其实脑海里应该有一个概念：利用 JSONP 格式返回的值一段要立即执行的 JavaScript 代码，所以不会像 ajax 的 XmlHttpRequest 那样可以监听不同事件对数据进行不同处理。</em></strong></p>
<p>处理结果如下所示：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3001_ajax_jsonp.png" alt=""></p>
<h3 id="使用-script标签原生实现-JSONP"><a href="#使用-script标签原生实现-JSONP" class="headerlink" title="使用 script标签原生实现 JSONP"></a>使用 script标签原生实现 JSONP</h3><p>经过上面的事件，你是不是觉得JSONP的实现和Ajax大同小异？其实，由于实现的原理不同，由JSONP实现的跨域调用不是通过 XmlHttpRequset对象，而是通过script标签，所以在实现原理上，JSONP和Ajax已经一点关系都没有了。看上去形式相似只是由于 jQuery对JSONP做了封装和转换。比如在上面的例子中，我们假设要传输的数据 data 格式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    name: "chiaki",</div><div class="line">    id": "3001"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么数据是如何传输的呢？HTTP 请求头的第一行如下：</p>
<blockquote>
<p>GET /ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032 HTTP/1.1</p>
</blockquote>
<p>可见，即使形式上是用 POST 传输一个 JSON 格式的数据，其实发送请求时还是转换成 GET请求。其实如果理解 JSONP的原理的话就不难理解为什么只能使用GET请求方法了。由于是通过script标签进行请求，所以上述传输过程根本上是以下的形式：</p>
<p><code>&lt;script src = &#39;http://localhost:3001/ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032&#39;&gt;&lt;/script&gt;</code></p>
<p>这样从服务器返回的代码就可以直接在这个script标签中运行了。下面我们自己实现一个JSONP：服务器3000请求页面的 JavaScript 代码中，只有回调函数 jsonpCallback：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"jsonpCallback: "</span>+data.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务器 3000请求页面还包含一个 script 标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src = <span class="string">'http://localhost:3001/jsonServerResponse?jsonp=jsonpCallback'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>服务器 3001上对应的处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/jsonServerResponse'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cb = req.query.jsonp</div><div class="line">    <span class="built_in">console</span>.log(cb)</div><div class="line">    <span class="keyword">var</span> data = <span class="string">'var data = &#123;'</span> + <span class="string">'name: $("#name").val() + " - server 3001 jsonp process",'</span> + <span class="string">'id: $("#id").val() + " - server 3001 jsonp process"'</span> + <span class="string">'&#125;;'</span></div><div class="line">    <span class="keyword">var</span> debug = <span class="string">'console.log(data);'</span></div><div class="line">    <span class="keyword">var</span> callback = <span class="string">'$("#submit").click(function() &#123;'</span> + data + cb + <span class="string">'(data);'</span> + debug + <span class="string">'&#125;);'</span></div><div class="line">    res.send(callback)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>与上面一样，我们在所获取的参数后面加上“-server 3001 jsonp process”<br>代表服务器对数据的操作。从代码中我么可以看到，处理函数除了根据参数做相应的处理，更多的也是进行字符串的拼接。最终的结果为：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3001_jsonp.png" alt=""></p>
<h3 id="JSONP-总结"><a href="#JSONP-总结" class="headerlink" title="JSONP 总结"></a>JSONP 总结</h3><p>至此，我们了解了 JSONP 的原理以及实现方式，它帮我们实现前端跨域请求，但是在实践的过程中，我们还是可以发现它的不足：</p>
<p>只能使用 GET 方法发起请求，这是由于 script 标签自身的限制决定的。</p>
<p>不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数。</p>
<h2 id="使用-CORS-实现跨域调用"><a href="#使用-CORS-实现跨域调用" class="headerlink" title="使用 CORS 实现跨域调用"></a>使用 CORS 实现跨域调用</h2><h3 id="什么是-CORS？"><a href="#什么是-CORS？" class="headerlink" title="什么是 CORS？"></a>什么是 CORS？</h3><p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了Web服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是JSONP模式的现代版。与JSONP不同，CORS除了GET要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。</p>
<h3 id="CORS-的实现"><a href="#CORS-的实现" class="headerlink" title="CORS 的实现"></a>CORS 的实现</h3><p>还是以 服务器 3000 上的请求页面向 服务器 3001 发送请求为例。<br>服务器 3000 上的请求页面 JavaScript 不变，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> data = &#123;</div><div class="line">            <span class="attr">name</span>: $(<span class="string">"#name"</span>).val(),</div><div class="line">            <span class="attr">id</span>: $(<span class="string">"#id"</span>).val()</div><div class="line">        &#125;;</div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">type</span>: <span class="string">'POST'</span>,</div><div class="line">            <span class="attr">data</span>: data,</div><div class="line">            <span class="attr">url</span>: <span class="string">'http://localhost:3001/cors'</span>,</div><div class="line">            <span class="attr">dataType</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">cache</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">timeout</span>: <span class="number">5000</span>,</div><div class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(data)</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'error '</span> + textStatus + <span class="string">' '</span> + errorThrown);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器 3001上对应的处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">app.post(&apos;/cors&apos;, function(req, res) &#123;</div><div class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</div><div class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);</div><div class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</div><div class="line">    res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;)</div><div class="line">    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);</div><div class="line">    var data = &#123;</div><div class="line">        name: req.body.name + &apos; - server 3001 cors process&apos;,</div><div class="line">        id: req.body.id + &apos; - server 3001 cors process&apos;</div><div class="line">    &#125;</div><div class="line">    console.log(data)</div><div class="line">    res.send(data)</div><div class="line">    res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在服务器中对返回信息的请求头进行了设置。最终的结果为：</p>
<p><img src="http://oab2ph6pv.bkt.clouddn.com/cross_origin/3000_to_3001_cors.png" alt=""></p>
<h3 id="CORS-中属性的分析"><a href="#CORS-中属性的分析" class="headerlink" title="CORS 中属性的分析"></a>CORS 中属性的分析</h3><p>Access-Control-Allow-Origin</p>
<blockquote>
<p>The origin parameter specifies a URI that may access the resource. The browser must enforce this. For requests without credentials, the server may specify “*” as a wildcard, thereby allowing any origin to access the resource.</p>
</blockquote>
<p>Access-Control-Allow-Methods</p>
<blockquote>
<p>Specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</p>
</blockquote>
<p>Access-Control-Allow-Headers</p>
<blockquote>
<p>Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.</p>
</blockquote>
<h3 id="3-4-CORS-与-JSONP-的对比"><a href="#3-4-CORS-与-JSONP-的对比" class="headerlink" title="3.4 CORS 与 JSONP 的对比"></a>3.4 CORS 与 JSONP 的对比</h3><p>CORS 除了 GET 方法外，也支持其它的 HTTP 请求方法如 POST、 PUT 等。<br>CORS 可以使用 XmlHttpRequest 进行传输，所以它的错误处理方式比 JSONP 好。<br>JSONP 可以在不支持 CORS 的老旧浏览器上运作。</p>
<h2 id="一些其它的跨域调用方式"><a href="#一些其它的跨域调用方式" class="headerlink" title="一些其它的跨域调用方式"></a>一些其它的跨域调用方式</h2><h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重。</p>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage()"></a>window.postMessage()</h3><p>这个方法是 HTML5 的一个新特性，可以用来向其他所有的window对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送MessageEvent，如果在函数执行的过程中调用了他，就会让后面的函数超时无法执行。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="external">参考</a></p>
<blockquote>
<p>本文转自<a href="http://tingandpeng.com/2016/09/05/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">前端跨域请求原理及实践</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[better-scroll初探]]></title>
      <url>http://djl.pub/2017/02/13/better-scroll%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>在做外卖APP项目时，用到了better-scroll这个插件，接口基本和iscroll一致，功能非常强大。<br><a id="more"></a></p>
<h1 id="文档资料"><a href="#文档资料" class="headerlink" title="文档资料"></a>文档资料</h1><p><a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="external">官方文档</a><br>主要资料还是参考<a href="https://iiunknown.gitbooks.io/iscroll-5-api-cn/content/index.html" target="_blank" rel="external">iscroll</a>这个插件，API接口都是一致的</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>一定要有两层<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> myScroll = <span class="keyword">new</span> IScroll(<span class="string">'#wrapper'</span>);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.getElementById(<span class="string">'wrapper'</span>);</div><div class="line"><span class="keyword">var</span> myScroll = <span class="keyword">new</span> IScroll(wrapper);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：使用的是querySelector 而不是 querySelectorAll，所以iScroll只会作用到选择器选中元素的第一个。如果你需要对多个对象使用iScroll，你需要构建自己的循环机制。</p>
</blockquote>
<p>outer层设置固定大小且为挂载点，overflow:hidden,inner层就是随内容增加。</p>
<h1 id="相关设置参数："><a href="#相关设置参数：" class="headerlink" title="相关设置参数："></a>相关设置参数：</h1><p><strong>bounce</strong>:当滚动器到达容器边界时他将执行一个小反弹动画，默认值为TRUE<br><strong>click:true</strong>    允许点击事件，在这里如果这个设置为TRUE的话，在触发点击事件时，有可能会两次触发（在pc端），这里我们就要通过如下判断<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(event._constructor)&#123;</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过better-scroll包装后的event事件对象会都一个<code>_constructor</code>属性，如果不进行判断，可能会触发两次点击事件。<br><strong>scrollX:true</strong>   横向滚动<br><strong>eventPassThrough:vertical</strong> 这个参数是在元素在横向滚动的同时，也是允许外层容器纵向滚动的<br><strong>mouseWheel</strong>:侦听鼠标滚轮事件<br><strong>scrollbars</strong>:是否显示为默认的滚动条<br>监听滚动事件，用于获取滚动高度<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(<span class="built_in">document</span>.getElementById(<span class="string">'wrapper'</span>),&#123;</div><div class="line">   <span class="attr">probeType</span>: <span class="number">3</span>  <span class="comment">//调节在scroll事件触发中探针的活跃度</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">scroll.on(<span class="string">'scroll'</span>, (pos) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(pos.x + <span class="string">'~'</span> + posx.y)</div><div class="line">  ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><a href="https://iiunknown.gitbooks.io/iscroll-5-api-cn/content/basicfeatures.html" target="_blank" rel="external">更多配置</a></p>
<h1 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h1><p><strong>滚动到某个元素</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(<span class="built_in">document</span>.getElementById(<span class="string">'wrapper'</span>))</div><div class="line">scroll.scrollToElement(el, <span class="number">500</span>)</div><div class="line"><span class="comment">// 第一个参数为X轴，第二个参数为Y轴</span></div></pre></td></tr></table></figure></p>
<p><strong>滚动到某个坐标</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(<span class="built_in">document</span>.getElementById(<span class="string">'wrapper'</span>))</div><div class="line">scroll.scrollTo(<span class="number">0</span>, <span class="number">500</span>)</div><div class="line"><span class="comment">// 第一个参数为X轴，第二个参数为Y轴</span></div></pre></td></tr></table></figure></p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>1 在使用b-scroll的时候，能够准确把握b-scroll初始化的时机是非常重要的。有些时候滚动是由于里面的内容撑开所导致，所以一定要保证里面的内容中的异步数据充分拿到之后进行b-srcoll初始化，所以我们必须要通过Vue的watch监听机制，在监听到数据变化的时候也进行一次b-scroll初始化，当然在ready时候也要进行初始化，因为当我们通过Vue-router进行切换时，整个DOM是重新加载的，但是watch监听数据变化是不会触发的，所以我们就必要在ready的时候进行一次初始化（当然这里也可以使用keep-alive属性阻止DOM重绘）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ready () &#123;</div><div class="line">    <span class="comment">// b-scroll 初始化</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">watch</span>: &#123;</div><div class="line">    <span class="string">'seller'</span>() &#123;</div><div class="line">      <span class="comment">// 检测异步数据seller是否获取到，获取到则scroll 初始化</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2 我们在获取滚动条位置时，一定要保证DOM已经重新绘制。在js中我们一般要这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ajax(<span class="string">'page.php'</span>, onCompletion);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCompletion</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Update here your DOM</span></div><div class="line"></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        myScroll.refresh();</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当然在vue中直接使用<code>this.$nextTick()</code>。当然我们不需要每次都来初始化b-scroll，我们只需要初始化一次，后面只需要刷新即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hScroll) &#123;</div><div class="line">        <span class="keyword">this</span>.hScroll = <span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$els.hScrollHook, &#123;</div><div class="line">            <span class="attr">scrollX</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">eventPassthrough</span>: <span class="string">'vertical'</span></div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.hScroll.refresh();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="其他的一些scroll插件"><a href="#其他的一些scroll插件" class="headerlink" title="其他的一些scroll插件"></a>其他的一些scroll插件</h1><p><a href="https://github.com/mkay581/scroll-js" target="_blank" rel="external">scroll.js</a>  主要接口和better-scroll差不多，但是功能没有那么强大，不过容易使用</p>
<p><a href="https://github.com/alicelieutier/smoothScroll" target="_blank" rel="external">smoothScroll</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> smoothScroll = <span class="built_in">require</span>(<span class="string">'smoothscroll'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> exampleBtn = <span class="built_in">document</span>.querySelector(<span class="string">'.example-button'</span>);</div><div class="line"><span class="keyword">var</span> exampleDestination = <span class="built_in">document</span>.querySelector(<span class="string">'.example-destination'</span>);</div><div class="line"></div><div class="line"><span class="comment">// This function can easily be an onClick handler in React components</span></div><div class="line"><span class="keyword">var</span> handleClick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  event.preventDefault();</div><div class="line"></div><div class="line">  smoothScroll(exampleDestination);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">exampleBtn.addEventListener(<span class="string">'click'</span>, handleClick);</div></pre></td></tr></table></figure></p>
<p>使用很简单就像锚点一样，直接跳到某个元素那里。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue-resource初探]]></title>
      <url>http://djl.pub/2017/02/12/vue-resource%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>vue-resource是用来发送ajax请求或者解决jsonp跨域问题，既可以在全局Vue中使用（即Vue.$http）也可以在vue实例中使用（即this.$http）<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>npm <code>$ npm install vue-resource</code><br>cdn  <code>&lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.0.3/vue-resource.min.js&quot;&gt;&lt;/script&gt;</code></p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>最常见的用法，目前还需要掌握这些<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GET /someUrl</span></div><div class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/someUrl'</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// success callback</span></div><div class="line">&#125;, (response) =&gt; &#123;</div><div class="line">  <span class="comment">// error callback</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果没有es6解析环境就不要写成箭头函数的形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// global Vue object</span></div><div class="line">Vue.http.get(<span class="string">'/someUrl'</span>, [options]).then(successCallback, errorCallback);</div><div class="line">Vue.http.post(<span class="string">'/someUrl'</span>, [body], [options]).then(successCallback, errorCallback);</div></pre></td></tr></table></figure>
<p>也可以vue实例中使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in a Vue instance</span></div><div class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/someUrl'</span>, [options]).then(successCallback, errorCallback);</div><div class="line"><span class="keyword">this</span>.$http.post(<span class="string">'/someUrl'</span>, [body], [options]).then(successCallback, errorCallback);</div></pre></td></tr></table></figure></p>
<p>一般我们请求的数据都会是一个对象或者字符串，我们通过response.body来获取响应内容，如果我们请求的是图片这样的二进制文件，我们通过response.blob来获取内容主题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="comment">// POST /someUrl</span></div><div class="line">  <span class="keyword">this</span>.$http.post(<span class="string">'/someUrl'</span>, &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">  </div><div class="line">    <span class="comment">// get body data</span></div><div class="line">    <span class="keyword">this</span>.someData = response.body;</div><div class="line"></div><div class="line">  &#125;, response =&gt; &#123;</div><div class="line">    <span class="comment">// error callback</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者图片等等二进制大文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/image.jpg'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// resolve to Blob</span></div><div class="line">  <span class="keyword">return</span> response.blob();</div><div class="line">  </div><div class="line">  &#125;).then(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// use image Blob</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p><a href="https://github.com/pagekit/vue-resource/blob/develop/docs/http.md" target="_blank" rel="external">response对象</a></p>
<h1 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h1><p><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="external">官方文档</a><br><a href="http://www.cnblogs.com/keepfool/p/5657065.html" target="_blank" rel="external">参考资料</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue-router初探]]></title>
      <url>http://djl.pub/2017/02/08/vue-router%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>最近在跟着视频学习开发一个外卖APP单页运用，开发中用到了vue-router来做路由管理，现在来进行简单的总结。<br><a id="more"></a></p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/home' &#125;"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/about' &#125;"</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"home"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>home<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"about"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>about<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> App=Vue.extend(&#123;&#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> home=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#home'</span></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> about=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#about'</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        <span class="keyword">var</span> vueRouter=<span class="keyword">new</span> VueRouter();</div><div class="line">        vueRouter.map(&#123;</div><div class="line">            <span class="string">'/home'</span>:&#123;</div><div class="line">                <span class="attr">component</span>:home</div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/about'</span>:&#123;</div><div class="line">                <span class="attr">component</span>:about</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        vueRouter.start(App,<span class="string">'#container'</span>);</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>注意：我们在使用Vue-router时不需要显示的创建Vue实例，我们只需要通过<code>vueRouter.start(App,&#39;#container&#39;);</code>将根组件<br>挂载到某个元素下就可以</strong></p>
<p>当然这里我们在打开<em><a href="http://localhost:63342/VueTest/vue-router-study.html#!/" target="_blank" rel="external">http://localhost:63342/VueTest/vue-router-study.html#!/</a></em>这个路径时router-view中的内容并不会显示<br>这里我们要定义一个主页,我们可以使用redirect进行重定向<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vueRouter.redirect(&#123;</div><div class="line">    <span class="string">'/'</span>:<span class="string">'/home'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>官方解释:为路由器定义全局的重定向规则。全局的重定向会在匹配当前路径之前执行。<br>如果发现需要进行重定向，原本访问的路径会被直接忽略而且不会在浏览器历史中留下记录。</p>
</blockquote>
<p>当然我们也可以使用go()方法直接导航到一个新的路由<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vueRouter.go(<span class="string">'/home'</span>);</div></pre></td></tr></table></figure></p>
<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><p>在一个路由中嵌套路由是一种比较常见的情况。直接看实例代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/home' &#125;"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/about' &#125;"</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"home"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>home<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123;path:'/home/article'&#125;"</span>&gt;</span>我的文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"article"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一篇文章，DJL箫氏<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"about"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>about<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> App=Vue.extend(&#123;&#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> article=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#article'</span>,</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> home=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#home'</span>,</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> about=Vue.extend(&#123;</div><div class="line">            <span class="attr">template</span>:<span class="string">'#about'</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        <span class="keyword">var</span> vueRouter=<span class="keyword">new</span> VueRouter();</div><div class="line">        vueRouter.map(&#123;</div><div class="line">            <span class="string">'/home'</span>:&#123;</div><div class="line">                <span class="attr">component</span>:home ,</div><div class="line">                <span class="attr">subRoutes</span>:&#123;</div><div class="line">                    <span class="string">'/article'</span>:&#123;</div><div class="line">                        <span class="attr">component</span>:article</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/about'</span>:&#123;</div><div class="line">                <span class="attr">component</span>:about</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        vueRouter.go(<span class="string">'/home'</span>);</div><div class="line">        vueRouter.start(App,<span class="string">'#container'</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>由示例可知，我们需要在子组件内部去使用v-link和router-view。</p>
<h1 id="v-link"><a href="#v-link" class="headerlink" title="v-link"></a>v-link</h1><p>v-link该指令接受一个 JavaScript 表达式，并会在用户点击元素时用该表达式的值去调用 router.go<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 字面量路径 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"'home'"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 效果同上 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: 'home' &#125;"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 具名路径 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当点击v-link所在的元素时，该元素会被添加一个<code>.v-link-active</code>的class，通过这个class我们可以用来表示当前选中激活状态。<br>当然如果我们不想用这个类名，我们可以通过linkActiveClass 来设置，或者在内联元素上单独设置<code>&lt;a v-link=&quot;{ path: &#39;/a&#39;, activeClass: &#39;custom-active-class&#39; }&quot;&gt;&lt;/a&gt;</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">    <span class="attr">linkActiveClass</span>: <span class="string">'active'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="具名路径"><a href="#具名路径" class="headerlink" title="具名路径"></a>具名路径</h1><p>当我们一个路径过长时，我们就可以找一个别名来代替这个路径，然后还可以设置参数。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123;name:'articleName',params:&#123;id:1&#125;&#125;"</span>&gt;</span>我的文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123;name:'articleName',params:&#123;id:2&#125;&#125;"</span>&gt;</span>我的文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123;name:'articleName',params:&#123;id:3&#125;&#125;"</span>&gt;</span>我的文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"article"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第&#123;&#123;$route.params.id&#125;&#125;篇文章，DJL箫氏<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> App=Vue.extend(&#123;&#125;);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> article=Vue.extend(&#123;</div><div class="line">        <span class="attr">template</span>:<span class="string">'#article'</span>,</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> vueRouter=<span class="keyword">new</span> VueRouter();</div><div class="line">    vueRouter.map(&#123;</div><div class="line">        <span class="string">'/article/:id'</span>:&#123;</div><div class="line">            <span class="attr">name</span>:<span class="string">'articleName'</span>,</div><div class="line">            <span class="attr">component</span>:article</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    vueRouter.go(<span class="string">'/article'</span>);</div><div class="line">    vueRouter.start(App,<span class="string">'#container'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们可以通过vue-router提供的相关接口取到对应的值 <a href="https://github.com/vuejs/vue-router/blob/1.0/docs/zh-cn/route.md" target="_blank" rel="external">路由规则和路由匹配</a></p>
<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:seller</span>=<span class="string">'seller'</span> <span class="attr">keep-alive</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们加上了<code>keep-alive</code>这个属性，当我们不加的时候，每次切换路由都会重新加载DOM，这样就会出现一些问题，例如下图</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-2-8/4536530-file_1486560148439_faff.jpg" alt="keep-alive示例图"></p>
<p>我们此时在<em>商品</em>路由下面有两个实物加入了购物车，这是此时的状态，加入我们不加<code>keep-alive</code>我们切换到<em>评论</em>路由，然后再切换到<em>商品</em>路由，由于DOM会刷新，那么我们此时的已经加入购物车的状态就会清空，这显示不是我们想要的。如下图：</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-2-8/65884667-file_1486560396173_c4d9.jpg" alt=""></p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>我使用Vue-router（0.7.3）来作路由管理，由于我们的Vue是1.0版本所以Vue-router要选用0.7.3而不是2.0的版本,对应关系如下：</p>
<blockquote>
<p>Vue 2.0  —  Vue-router 2.0   <a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="external">Vue-router 2.0 文档</a></p>
<p>Vue 1.0  —  Vue-router 0.7.3 <a href="https://github.com/vuejs/vue-router/tree/1.0/docs/zh-cn" target="_blank" rel="external">Vue-router 0.7.3 文档</a></p>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>上面写的是我最基本的用法，也是我目前用到的，当然他还有很多用途，现在还没用到，等用到的时候再加上，最后附上另一篇参考文章。<a href="http://www.cnblogs.com/keepfool/p/5690366.html" target="_blank" rel="external">Vue.js——vue-router 60分钟快速入门</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webpack1.0初探]]></title>
      <url>http://djl.pub/2017/02/07/webpack1.0%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>webpack是目前最热门的前端资源模块化管理和打包工具,它能把各种资源，包括 jxs、coffeeJS、less／sass，甚至图片，当作模块来加载和使用。当我们需要使用这些资源时只需要require进来，方便模块化开发。<br><a id="more"></a></p>
<h1 id="webpack-使用"><a href="#webpack-使用" class="headerlink" title="webpack 使用"></a><a href="https://webpack.github.io/docs/usage.html" target="_blank" rel="external">webpack 使用</a></h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先全局安装<code>webpack $npm install webpack -g</code></p>
<p>再安装<code>webpack-dev-server</code>这是一个webpack提供的静态开发环境服务器，用来开发调试</p>
<blockquote>
<p>注：如果是在开发环境中用到的包我们使用<code>--save-dev</code>的参数，如果生产环境用到的如jQuery，我们直接只用<code>save</code>参数</p>
</blockquote>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>使用webpack最重要的就是配置文件<code>webpack.config.js</code>，和gulp等等工具一样都有一个配置文件</p>
<h2 id="常用配置选项"><a href="#常用配置选项" class="headerlink" title="常用配置选项"></a>常用配置选项</h2><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">entry : &#123;</div><div class="line">    <span class="string">'admin'</span>: <span class="string">'./admin/admin.js'</span>,</div><div class="line">    <span class="string">'custom'</span>:<span class="string">'./custom/custom.js'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>entry表示webpack的入口文件，可以是多个，那么webpack会一次执行。</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output:&#123;</div><div class="line">    <span class="attr">filename</span>:<span class="string">"[name].bundle.js"</span>,</div><div class="line">    <span class="attr">path</span>:path.join(__dirname,<span class="string">'dist'</span>),</div><div class="line">    <span class="attr">publicPath</span>:<span class="string">'/dist/'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>filename</code>编译后输出文件的名字<br><code>path</code>:编译后文件的存储位置</p>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins: []"></a>plugins: []</h3><h4 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h4><p>代码压缩 UglifyJsPlugin。这是一个webpack内置的插件，我们在使用时，只需要在webpack.config.js 引入，然后在plugins选项中注册</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="attr">plugins</span>:[<span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">             <span class="attr">compress</span>: &#123;</div><div class="line">                 <span class="attr">warnings</span>: <span class="literal">false</span></div><div class="line">             &#125;</div><div class="line">         &#125;)]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>他会将所有的js文件进行压缩，但是我们只希望生成环境的代码压缩，开发环境的文件并不希望压缩</p>
<p>如果我们只想在build时候uglify,那么我们可以设置一个参数，在build的启动项中，然后利用第三方包<code>node-argv</code>去读这个参数，然后就可以通过if来进行判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> args = <span class="built_in">require</span>(<span class="string">'node-argv'</span>);</div><div class="line"><span class="keyword">if</span>(args.minify)&#123;<span class="comment">// 这个minify就是自己设置的参数</span></div><div class="line">    <span class="comment">// toDo ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种是读取环境变量的方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line"><span class="keyword">var</span> env = process.env.NODE_ENV;</div><div class="line"><span class="keyword">if</span>(env === <span class="string">'production'</span>)&#123;</div><div class="line">    <span class="comment">// toDo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"start"</span>: <span class="string">"NODE_ENV=dev webpack-dev-server --progress --colors --hot --inline --d"</span>,</div><div class="line">    <span class="attr">"bulid"</span>: <span class="string">"NODE_ENV=producrion webpack-dev-server --progress --colors --hot --inline --d"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"></div><div class="line"><span class="comment">// definePlugin 会把定义的string 变量插入到Js代码中。</span></div><div class="line"><span class="keyword">var</span> definePlugin = <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">  <span class="attr">__DEV__</span>: <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(process.env.BUILD_DEV || <span class="string">'true'</span>)),</div><div class="line">  <span class="attr">__PRERELEASE__</span>: <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(process.env.BUILD_PRERELEASE || <span class="string">'false'</span>))</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./main.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [definePlugin]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>配置完成后，就可以使用 <code>BUILD_DEV=1 BUILD_PRERELEASE=1</code> webpack来打包代码了。 值得注意的是，<code>webpack -p</code>会删除所有无作用代码，也就是说那些包裹在这些全局变量下的代码块都会被删除，这样就能保证这些代码不会因发布上线而泄露。</p>
<h4 id="Open-Browser-Webpack-Plugin"><a href="#Open-Browser-Webpack-Plugin" class="headerlink" title="Open Browser Webpack Plugin"></a><a href="https://github.com/baldore/open-browser-webpack-plugin" target="_blank" rel="external">Open Browser Webpack Plugin</a></h4><p>使用<br><code>npm i --save-dev open-browser-webpack-plugin</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> OpenBrowserPlugin = <span class="built_in">require</span>(<span class="string">'open-browser-webpack-plugin'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: path.resolve(__dirname, <span class="string">'lib/entry.js'</span>),</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: __dirname + <span class="string">"/bundle/"</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">"bundle.js"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> OpenBrowserPlugin(&#123; <span class="attr">url</span>: <span class="string">'http://localhost:3000'</span> &#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>详细配置请见<a href="https://github.com/baldore/open-browser-webpack-plugin" target="_blank" rel="external">官网</a></p>
<h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p><a href="https://webpack.github.io/docs/list-of-loaders.html" target="_blank" rel="external">loader lists</a></p>
<h4 id="css-样式文件"><a href="#css-样式文件" class="headerlink" title="css 样式文件"></a>css 样式文件</h4><p> css-loader的作用是将css文件写入一个js文件里面</p>
<p> style-loader的作用就是将这个转换后的样式文件解析插入到HTML中</p>
<p> loader 有两种配置方法，一种是给每个entry文件单独添加loader例如<code>require(&#39;style!css!./admin.css&#39;);</code>注意在这里每一个loader后面都有一个”!”。这个顺序是<em>从右往左</em>的<br>另一种方式是在webpack.config.js文件中整体配置使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [&#123;</div><div class="line">            <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</div><div class="line">            <span class="attr">loaders</span>:[<span class="string">'style'</span>,<span class="string">'css'</span>]</div><div class="line">        &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>统一使用loaders:[]数组的方式</p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>对于引用图片有两种引用模式，一种是直接require，另一种是转换成base64（一般针对小图标）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">loaders: [</div><div class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">loader</span>: <span class="string">'file-loader'</span>&#125;,</div><div class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125; <span class="comment">// 内联的base64的图片地址，图片要小于8k，直接的url的地址则不解析</span></div><div class="line">    ]</div></pre></td></tr></table></figure></p>
<h4 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h4><p>node-sass模块和sass-loader。<br><a href="https://github.com/jtangelder/sass-loader" target="_blank" rel="external">参考资料</a></p>
<h4 id="ES6-加载"><a href="#ES6-加载" class="headerlink" title="ES6 加载"></a>ES6 加载</h4><p>这个依赖了3个模块<code>Babel-loader加载器</code>、<code>babel-preset-es2015</code>、<code>babel-core</code>。当然<br>如果是在react中使用还要依赖<code>babel-preset-react</code>。两种方式使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  <span class="attr">loaders</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.js?$/</span>,</div><div class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">      <span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">      <span class="attr">query</span>: &#123;</div><div class="line">        <span class="attr">presets</span>: [<span class="string">'es2015'</span>]</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">   <span class="attr">loaders</span>:[</div><div class="line">     &#123;</div><div class="line">       <span class="attr">test</span>: <span class="regexp">/\.js[x]?$/</span>,</div><div class="line">       <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">       <span class="attr">loader</span>: <span class="string">'babel-loader?presets[]=es2015'</span></div><div class="line">     &#125;,</div><div class="line">   ]</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><em>NOTE:The query string is appended to the loader with ?. i.e. url-loader?mimetype=image/png.</em></p>
<p>当然也可以配置一个.babelrc的配置文件<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">"presets"</span>: [ <span class="string">"es2015"</span> ] &#125;</div></pre></td></tr></table></figure></p>
<h3 id="resolve-配置选项"><a href="#resolve-配置选项" class="headerlink" title="resolve 配置选项"></a>resolve 配置选项</h3><p>如果你希望在require文件时省略文件的扩展名，只需要在webpack.config.js中添加 resolve.extensions 来配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">  <span class="comment">// 现在你require文件的时候可以直接使用require('file')，不用使用require('file.coffee')</span></div><div class="line">  extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.coffee'</span>]  <span class="comment">// 但是必须要在前面加一个空的字符串，否则会导致无法加载的情况</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优化通用代码"><a href="#优化通用代码" class="headerlink" title="优化通用代码"></a>优化通用代码</h3><p>Feed和Profile页面存在大量通用代码(比如React、公共的样式和组件等等)。webpack可以抽离页面间公共的代码，生成一个公共的bundle文件，供这两个页面缓存使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> commonsPlugin =</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>); <span class="comment">// 引入插件</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">    <span class="attr">Profile</span>: <span class="string">'./profile.js'</span>,</div><div class="line">    <span class="attr">Feed</span>: <span class="string">'./feed.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">'build'</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].js'</span> <span class="comment">// 为上面entry的key值</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [commonsPlugin]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在上一步引入自己的bundle之前引入<script src="build/common.js"></script></p>
<h3 id="生成Source-Maps（使调试更容易）"><a href="#生成Source-Maps（使调试更容易）" class="headerlink" title="生成Source Maps（使调试更容易）"></a>生成Source Maps（使调试更容易）</h3><p>开发总是离不开调试，如果可以更加方便的调试当然就能提高开发效率，<br>不过打包后的文件有时候你是不容易找到出错了的地方对应的源代码的位置的，Source Maps就是来帮我们解决这个问题的。<br>通过简单的配置后，Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，<br>使得编译后的代码可读性更高，也更容易调试。</p>
<p>在webpack的配置文件中配置source maps，需要配置devtool，<br>它有以下四种不同的配置选项，各具优缺点，描述如下：</p>
<p>devtool选项   配置结果</p>
<p><code>source-map</code>     在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度；</p>
<p><code>cheap-module-source-map</code>   在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</p>
<p><code>eval-source-map</code>   使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项；</p>
<p><code>cheap-module-eval-source-map</code>  这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</p>
<p>正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。</p>
<p>在学习阶段以及在小到中性的项目上，eval-source-map是一个很好的选项，不过记得只在开发阶段使用它，继续上面的例子，进行如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  devtool: &apos;eval-source-map&apos;,//配置生成Source Maps，选择合适的选项</div><div class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/public&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>cheap-module-eval-source-map</code>方法构建速度更快，但是不利于调试，推荐在大型项目考虑da时间成本是使用。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>我们可以直接通过webpack-dev-server（前提是全局安装）命令直接在命令窗口中启动，也可以通过设置package.json<br>一个启动项，例如：<code>&quot;start&quot;: &quot;webpack-dev-server --progress --colors --hot --inline&quot;</code>这里就不需要webpack-dev-server<br>这个包是全局安装。这种启动方式，寻找包会到local环境中查找，找不到再去查找全局。</p>
<p><code>--progress</code>这个参数是显示进度</p>
<p><code>--colors</code> 显示颜色，这样命令窗口看起来比较爽</p>
<p><code>--hot</code> 启动热加载，就是文件保存，浏览器自动刷新，类似于liveonload这个功能</p>
<p><code>--inline</code> 把内容注入到相应文件中</p>
<p><code>--d</code> 开启debug模式，这样在浏览器中我们就可以看到源码</p>
<p>在entry的js文件里面可以require任何一个文件(css,js等等)</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>1  视频老师用的是mac系统，正则匹配文件路径时这样<code>/\/images\//</code>，但是我的是Windows的系统所以文件路径匹配应该是这样<code>/\\img\\/</code></p>
<p>2 在webpack.config.js配置文件中，应该是不能使用ES6的语法的。</p>
<h1 id="不错的webpack资料"><a href="#不错的webpack资料" class="headerlink" title="不错的webpack资料"></a>不错的webpack资料</h1><p><a href="https://github.com/petehunt/webpack-howto/blob/master/README-zh.md" target="_blank" rel="external">webpack-howto</a></p>
<p><a href="http://www.maiziedu.com/course/570/" target="_blank" rel="external">视频资料</a></p>
<p><a href="https://segmentfault.com/a/1190000008032524" target="_blank" rel="external">webpack 入门实战</a></p>
<p><a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">阮一峰老师webpack</a></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>感觉这篇写的并不是很好，然而webpack2.0出来了，我1.0才开始，嗯对Vue似乎也是这样。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vuex初探]]></title>
      <url>http://djl.pub/2017/01/29/Vuex%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>前篇我们谈到在<a href="http://djl.pub/2017/01/21/Vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E4%BB%B6/#组件通信">Vue组件中进行通信的几种方式</a>，父子组件中可以通过props属性，兄弟组件可以通过事件分发。当然很明显组件的独立性会有所降低，那么这里有另外一种方式就是通过Vuex。核心思想就是把子组件中需要共享的数据通过Vuex来进行管理。这里我使用的是Vuex1.0版本。<br><a id="more"></a></p>
<p><a href="https://github.com/vuejs/vuex/tree/1.0/docs/zh-cn" target="_blank" rel="external">官方文档1.0</a></p>
<p>Vuex 1.0 和 2.0都完全支持 Vue 1.0 和 2.0。上面是1.0版本的文档，千万不要安装的2.0版本，查看的却是1.0的文档资料</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vuex@1.0.0</div></pre></td></tr></table></figure>
<p>这里我们以一个例子来讲解Vuex的基本使用。我们实现一个计数器，实现加一和减一功能。这里我们创建3个组件<code>Display.vue</code>、<code>Increment.vue</code>和<code>Decrement.vue</code>。很简单我们可以分析出这三个组件中会共享一个数据那就是<code>count</code>，都需要知道当前计数器的数值是多少。所以这个数据要放在Vuex中进行管理，以后<code>Display.vue</code>、<code>Increment.vue</code>和<code>Decrement.vue</code>这三个组件就是通过访问Vuex来操作<code>count</code>这个数据。</p>
<h2 id="Vuex基本流程"><a href="#Vuex基本流程" class="headerlink" title="Vuex基本流程"></a>Vuex基本流程</h2><p>在这里首先借用官方文档中的一幅图片</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-29/63997298-file_1485700766566_d0e.png" alt="Vuex流程图"></p>
<p>从这里我们会知道一下几个核心概念</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在使用Vuex时，我们一般会有如下文件结构：</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-29/92859228-file_1485701346600_9217.jpg" alt="Vuex基本文件结构"></p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>state对象保存的就是共享数据的当前状态</p>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>提供操作共享数据的具体方法，能够直接操作state对象。</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>在vue组件中，我们可以直接通过this.$store来访问共享数据，但是我们一般不会这么做，我们还是通过Vuex提供的getter属性来取得。</p>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><blockquote>
<p>action 是一种专门用来被 component 调用的函数。action 函数能够通过分发相应的 mutation 函数，来触发对 store 的更新。action 也可以先从 HTTP 后端或 store 中读取其他数据之后再分发更新事件。</p>
</blockquote>
<p>actions不能直接操作state数据的，而是通过dispatch相应的mutations来实现。一般组件直接调用的就是actions中提供的函数接口，而不会去直接调用mutations。</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-29/32989864-file_1485700769110_11d56.jpg" alt=""></p>
<p>上图是我自己画的一个调用关系图，从上面我们可以看到，调用过程还是比较复杂的，所以如果是比较小的项目，就不要使用Vuex了。</p>
<h2 id="开始动手吧"><a href="#开始动手吧" class="headerlink" title="开始动手吧"></a>开始动手吧</h2><p>首先我们通过vue-cli脚手架搭建一个vue工程，如果不是很清楚可以看看我的另一篇博客。然后我们构建<code>Display.vue</code>、<code>Increment.vue</code>和<code>Decrement.vue</code>三个组件。然后新建一个vuex文件夹下面有<code>store.js</code>、<code>actions.js</code>和<code>getters.js</code>。工程目录结构如下图所示。</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-29/90277051-file_1485702257444_17c2d.jpg" alt="计数器工程目录结构"></p>
<h3 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="comment">//告诉Vue使用vuex</span></div><div class="line">Vue.use(Vuex);</div><div class="line"></div><div class="line"><span class="comment">//创建一个对象来保存应用启动时的初始状态</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> state = &#123;</div><div class="line"><span class="comment">// 应用启动时，count为0</span></div><div class="line">    count: <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建一个对象存储一系列我们接下来要写的mutation函数</span></div><div class="line"><span class="keyword">const</span> mutations = &#123;</div><div class="line"><span class="comment">//    放置我们状态变更函数</span></div><div class="line">    INCREMENT (state,amount) &#123;</div><div class="line">         state.count = state.count + amount;</div><div class="line">    &#125;,</div><div class="line">    DECREMENT (state,amount) &#123;</div><div class="line">        state.count = state.count - amount;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//整合初始状态和变更函数，我们就得到了我们所需的store</span></div><div class="line"><span class="comment">// 至此，这个store就可以连接到我们的应用中</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    state,</div><div class="line">    mutations</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>简单来说这个文件就做了几件事<br>1 告诉vue我们这个项目使用了vuex<br>2 定义添加共享数据count<br>3 提供操作共享数据的相关函数接口<code>INCREMENT</code>、<code>DECREMENT</code><br>4 导出这个store供外部使用</p>
<h3 id="actions-js"><a href="#actions-js" class="headerlink" title="actions.js"></a>actions.js</h3><p>action 是一种专门用来被 component 调用的函数。也就是说<code>Display.vue</code>、<code>Increment.vue</code>和<code>Decrement.vue</code>三个组件可能要使用actions.js。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> incrementCounter = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;dispatch, state&#125;</span>) </span>&#123;</div><div class="line">     dispatch(<span class="string">'INCREMENT'</span>,<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrementCounter = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;dispatch, state&#125;</span>) </span>&#123;</div><div class="line">    dispatch(<span class="string">'DECREMENT'</span>,<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>dispatch中的字符串参数一定要和store.js中mutations对象中的名字对应</strong><br>这里我们可以通过dispatch给对应mutations中的函数提供参数，这里就是<code>1</code>。</p>
<h3 id="Increment-vue"><a href="#Increment-vue" class="headerlink" title="Increment.vue"></a>Increment.vue</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'increment'</span>&gt;</span>Increment +1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">import</span> &#123; incrementCounter &#125; <span class="keyword">from</span> <span class="string">'../vuex/action'</span></div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">        <span class="attr">vuex</span>:&#123;</div><div class="line">            <span class="attr">actions</span>:&#123;</div><div class="line">                <span class="attr">increment</span>:incrementCounter</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当我们点击按钮时，会触发click事件调用<code>increment</code>方法，从而调用<code>incrementCounter</code>这个action，通过这个action调用直接操作数据的mutation。于是就这样实现了加一操作。</p>
<h3 id="Display-vue"><a href="#Display-vue" class="headerlink" title="Display.vue"></a>Display.vue</h3><p>接下来就是通过Display.vue这个组件来显示</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;counterValue&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">import</span> &#123; getCount &#125; <span class="keyword">from</span> <span class="string">'../vuex/getters'</span></div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">        <span class="attr">vuex</span>:&#123;</div><div class="line">          <span class="attr">getters</span>:&#123;</div><div class="line">            <span class="attr">counterValue</span>:getCount</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们可以看到并没有直接这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vuex:&#123;</div><div class="line">  <span class="attr">getters</span>:&#123;</div><div class="line">    counterValue (state) &#123;</div><div class="line">     <span class="keyword">return</span> state.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>1 我们可能需要使用 getter 函数返回需经过计算的值（比如总数，平均值等）。<br>2 在大型应用里，很多组件之间可以复用同一个 getter 函数。<br>3 如果这个值的位置改变了（比如从 store.count 变成了 store.counter.value），你只需要改一个 getter 方法，而不是一堆组件。</p>
</blockquote>
<h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Increment</span>&gt;</span><span class="tag">&lt;/<span class="name">Increment</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Decrement</span>&gt;</span><span class="tag">&lt;/<span class="name">Decrement</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Display</span>&gt;</span><span class="tag">&lt;/<span class="name">Display</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">import</span> Increment <span class="keyword">from</span> <span class="string">'./components/Increment'</span></div><div class="line"><span class="keyword">import</span> Decrement <span class="keyword">from</span> <span class="string">'./components/Decrement'</span></div><div class="line"><span class="keyword">import</span> Display <span class="keyword">from</span> <span class="string">'./components/Display'</span></div><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./vuex/store'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    Increment,</div><div class="line">    Decrement,</div><div class="line">    Display</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">store</span>:store</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里没有什么好特别说明，就是一般我们在根组件中注入store，这样我们在每个组件中都可以访问。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上只实现了加一的功能，减一的功能类似，大家可以自己下来试试，如果觉得这个太容易，可以试一试这个<a href="https://segmentfault.com/a/1190000005015164#articleHeader5" target="_blank" rel="external">应用笔记项目</a>。</p>
<p>大年初二，23:30分。。。。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue学习之组件]]></title>
      <url>http://djl.pub/2017/01/21/Vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>组件在Vue中占有举足轻重的地位，在开发<em>高仿饿了么外卖APP</em>中也见识到了组件化开发的便捷和灵活。下面来总结一下。<br><a id="more"></a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://v1-cn.vuejs.org/guide/components.html" target="_blank" rel="external">官方Vue组件文档</a><br><a href="http://www.cnblogs.com/keepfool/p/5625583.html" target="_blank" rel="external">Vue.js——60分钟组件快速入门（上篇）</a><br><a href="http://www.cnblogs.com/keepfool/p/5637834.html" target="_blank" rel="external">Vue.js——60分钟组件快速入门（下篇）</a></p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义</span></div><div class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 注册</span></div><div class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</div><div class="line"><span class="comment">// 创建根实例</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#example'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个组件是全局注册。</p>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>有时我们需要在一个父组件下面注册另一个子组件，而这个子组件只能被这个父组件使用，那么我们就需要使用局部注册。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Child = Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;)</div><div class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'...'</span>,</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    <span class="comment">// &lt;my-component&gt; 只能用在父组件模板内</span></div><div class="line">    <span class="string">'my-component'</span>: Child</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>可以看到就是在一个父组件中的<strong>components</strong>属性中添加子组件。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>在子组件中data属性值是一个匿名函数的返回值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> MyComponent = Vue.extend(&#123;</div><div class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果不这样，那么每个实例都将共享这一个data，就会造成混乱。</p>
<ol>
<li>我们在子组件模板时，既可以以下面这种方式指定</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>但是我们更推荐使用H5的template标签来做，尤其是在子组件模板比较大的时候<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmpl"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>这是一个组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> component = Vue.extend(&#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">"#tmpl"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当然对子组件模板也有一些要求，不然会解析出错</p>
<blockquote>
<ul>
<li>a 不能包含其它的交互元素（如按钮，链接）</li>
<li>ul 和 ol 只能直接包含 li</li>
<li>select 只能包含 option 和 optgroup</li>
<li>table 只能直接包含 thead, tbody, tfoot, tr, caption, col,   colgroup</li>
<li>tr 只能直接包含 th 和 td </li>
</ul>
</blockquote>
<p> <a href="http://v1-cn.vuejs.org/guide/components.html#模板解析" target="_blank" rel="external">更多模板注意事项</a></p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>组件使用中最难的就是解决通信问题。一般有一下几种方式和情况</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>第一种就是在子组件中利用props属性，来实现父子组件中的通信。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tmlp-a</span> <span class="attr">:props-num</span>=<span class="string">"num"</span>&gt;</span><span class="tag">&lt;/<span class="name">tmlp-a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmlp-a"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;propsNum&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'tmlp-a'</span>,&#123;</div><div class="line">    <span class="attr">template</span>:<span class="string">"#tmlp-a"</span>,</div><div class="line">    <span class="attr">props</span>:[<span class="string">'propsNum'</span>],</div><div class="line">    <span class="attr">methods</span>:&#123;</div><div class="line">        <span class="attr">add</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.propsNum++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>:<span class="string">"#wrap"</span>,</div><div class="line">    <span class="attr">data</span>:&#123;</div><div class="line">        <span class="attr">num</span>:<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>通过props这个属性我们就可以拿到父组件的data数据，然后我们就可以操作这个数据，但是这里是一个单项问题，即我们在子组件中操作这个数据，并不会影响父组件中对应的数据，当然有一个办法就是通过props传递过来的是一个引用类型数据而不是一个基本变量，但是这无疑很麻烦。那么Vue提供了另外一种方法，那就是通过<strong>.sync</strong>修饰符来做。把代码做一点修改即可：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tmlp-a</span> <span class="attr">:props-num.sync</span>=<span class="string">"num"</span>&gt;</span><span class="tag">&lt;/<span class="name">tmlp-a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="Vue-dispatch"><a href="#Vue-dispatch" class="headerlink" title="Vue.$dispatch"></a>Vue.$dispatch</h3><p>第二种方式就是使用Vue.$dispatch（事件配发）来做，这种用法主要用在两个平级的子组件之间，它们有共同的父组件。也就是来解决兄弟组件间的通信问题，因为在一般情况下是不直接通信的（为了组件的独立性），那么有时候我们又有这样的需求。首先来看看通信的流程图：</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-21/79403842-file_1485003651843_8299.jpg" alt="dispatch原理图"></p>
<p>上面的通信方式，就如下面的对话。</p>
<blockquote>
<p>大儿子小明：老爸，让弟弟帮我拿一下快递，快递号码为（3737） //派发事件并传递参数3737<br>老爸听到了大儿子的请求，并开始行动 //父组件事件响应函数做出响应<br>老爸跑去找小儿子小明 //v-ref指令找到另一个子组件<br>爸爸：小华，快去拿一个快递，快递号码为（3737）<br>小儿子小明腾腾腾就去拿快递，告诉别人快递号码。</p>
</blockquote>
<p>代码示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">child-a</span> &gt;</span><span class="tag">&lt;/<span class="name">child-a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">child-b</span>  <span class="attr">v-ref:other-child</span>&gt;</span><span class="tag">&lt;/<span class="name">child-b</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"child-a"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"sendMsg"</span>&gt;</span>发送信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"child-b"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;receiveMsg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'#container'</span>,</div><div class="line">    <span class="attr">components</span>: &#123;</div><div class="line">        <span class="string">'childA'</span>: &#123;</div><div class="line">            <span class="attr">template</span>: <span class="string">'#child-a'</span>,</div><div class="line">            <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> &#123;</div><div class="line">                    <span class="attr">msg</span>:<span class="string">'DJL箫氏'</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">methods</span>: &#123;</div><div class="line">                <span class="attr">sendMsg</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">this</span>.$dispatch(<span class="string">'fatherTodo'</span>,<span class="keyword">this</span>.msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">'childB'</span>: &#123;</div><div class="line">            <span class="attr">template</span>: <span class="string">'#child-b'</span>,</div><div class="line">            <span class="attr">data</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">              <span class="keyword">return</span> &#123;</div><div class="line">                  <span class="attr">receiveMsg</span>:<span class="string">''</span></div><div class="line">              &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">methods</span>: &#123;</div><div class="line">                <span class="attr">receiveMsgFromA</span>: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">                    <span class="keyword">this</span>.receiveMsg = msg;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">'我接受到来自A的数据：'</span>+msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">events</span>: &#123;</div><div class="line">        <span class="attr">fatherTodo</span>: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.$refs.childB.receiveMsgFromA(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样就可以在兄弟组件实现通信</p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>最后一种方式就是利用<a href="https://github.com/vuejs/vuex/tree/1.0/docs/zh-cn" target="_blank" rel="external">Vuex</a>,关于这种方法，我会专门花一篇来写，敬请期待。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue学习之生命周期]]></title>
      <url>http://djl.pub/2017/01/21/Vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>生命周期在组件开发总非常重要，尤其是能在适当的时机取得数据,做一些初始化准备。下面我们来简单的聊聊Vue生命周期。<br><a id="more"></a><br>这里首先来看看Vue官方文档给出的生命周期示意图。</p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-21/75404643-file_1484986273994_1820a.png" alt="Vue生命周期"></p>
<p>在这里我主要讨论init、created、beforeCompile、compiled、ready、beforeDestroy、destroyed这几个生命周期钩子函数。</p>
<p>init：在实例开始初始化时同步调用。此时数据观测、事件和 watcher 都尚未初始化。也是说在这里this.$el和this.$data都是拿不到的。</p>
<p>created:在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定，计算属性，方法，watcher/事件回调。但是还没有开始 DOM 编译，$el还不存在。也就是在这里已经可以访问this.$data了了。但是此时还没有进行模板编译。</p>
<p>beforeCompile：编译模板前，$el已经存在了。</p>
<p>compiled：模板编译完成，此时Vue指令已经生效，但是不能保证此时已经插入到文档中。</p>
<p>ready：在编译结束后和$el第一次插入到文档中的时候。这时可以从整个文档中获取到模板中的元素。</p>
<p>beforeDestroy：在销毁实例时调用，所有功能都还保持。</p>
<p>destroyed：在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，所有的子实例也已经被销毁。如果有离开过渡，destroyed 钩子在过渡完成之后调用。与挂载元素解除绑定</p>
<p>代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'-----init----'</span>)</div><div class="line">    <span class="comment">//  也就是说在这里$el获取不到，数据观测也没有建立，事件绑定等等都没有完成  实例初始化时同步调用</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里$el依然获取不到，但是数据观测已经建立，也就是说可以获得数据了，但是依然没有开始编译，也就是说Vue</span></div><div class="line">    <span class="comment">// 的一些指令是不起作用的</span></div><div class="line">    <span class="comment">// 实例创建后同步调用</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'----created---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">beforeCompile</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---beforeCompile---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">compiled</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---compiled---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="comment">// 此时指令已经生效，但是不确保插入到文档中</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">ready</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---ready---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="comment">// 在编译结束后和$el第一次插入到文档中的时候</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))  <span class="comment">//这时可以从整个文档中获取到模板中的元素</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'--在ready钩子函数中销毁实例--'</span>)</div><div class="line">    <span class="keyword">this</span>.$destroy(<span class="literal">true</span>);</div><div class="line">&#125;,</div><div class="line"><span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 在销毁实例时调用，所有功能都还保持</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---beforeDestroy---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;,</div><div class="line"><span class="attr">destroyed</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，所有的子实例也已经被销毁。</span></div><div class="line">    <span class="comment">// 与挂载元素解除绑定</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'---destroyed---'</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ok3x4ia9b.bkt.clouddn.com/17-1-21/56048235-file_1484985260986_9fc2.jpg" alt="结果"></p>
<p>生命周期在组件开发总非常重要，尤其是能在适当的时机取得数据。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js学习]]></title>
      <url>http://djl.pub/2017/01/17/Vue-js%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>最近在慕课网上面买了一套<a href="http://coding.imooc.com/class/74.html" target="_blank" rel="external">高仿饿了么APP</a>视频,个人认为<br>对于我这种没有实际经验（还没有正式工作），又在学习Vue.js的人来说，绝对是非常值得的（不是打广告）。<br>而这套课程中主要用到了<strong>Vue</strong>、<strong>Vue-router</strong>、<strong>Vue-source</strong>、<strong>webpack</strong>、<strong>ES6</strong>、<strong>ESLint</strong>等等<br>所以通过这次课程我对于这些都有了一个大致了解。而这篇文章主要讲解Vue的1.0版本。我将会接下来的时间利用Vue2.0来实现一遍。<br><a id="more"></a></p>
<p><a href="http://v1-cn.vuejs.org/guide/" target="_blank" rel="external">官方文档</a></p>
<p>Vue.js的两大特性：组件化开发、数据驱动。之前没有学习任何框架的时候，开发过一个H5的音乐播放器，里面涉及<br>了大量DOM操作，实在很费神，如果使用Vue来做的话应该简单很多。由于Vue的官方文档已经写的比较好了而且又有中文版，<br>所以这里我并不打算讲Vue的一些基本知识（相比官方文档也讲不出什么花出来）</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h2 id="常见的用法"><a href="#常见的用法" class="headerlink" title="常见的用法"></a>常见的用法</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo初探---让写作飞起来]]></title>
      <url>http://djl.pub/2017/01/13/hexo%E5%88%9D%E6%8E%A2---%E8%AE%A9%E5%86%99%E4%BD%9C%E9%A3%9E%E8%B5%B7%E6%9D%A5/</url>
      <content type="html"><![CDATA[<p>这两天一直在捣鼓hexo，虽然不是很难，但是在搭建过程中，还是遇到了一些问题，导致花了两天。网上有很多相关教程，但是很多都含糊不清，其实让我豁然开朗的还是这篇文章，在此特别谢谢这位博主<a href="https://my.oschina.net/ryaneLee/blog/638440" target="_blank" rel="external">小白独立搭建博客–Github Pages和Hexo简明教程</a>。好了下面我们直接开始吧<br><a id="more"></a></p>
<h2 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h2><p><a href="https://git-scm.com/download" target="_blank" rel="external">Git</a>：版本控制器   </p>
<p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="external">Node</a>：提供服务器端JavaScript开发环境</p>
<p><a href="https://github.com" target="_blank" rel="external">GitHub</a>：需注册一个账号</p>
<p>在这里只提供下载链接，安装过程基本就是下一步了。</p>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1 安装hexo"></a>1 安装hexo</h3><p>安装好上述工具后，我们开始安装hexo，首先打开git,鼠标右键–&gt;git bash here</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-970cfcfc5c4d9e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Git_bash.png"></p>
<p>打开效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-f6d8b39d88552ff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开Git.png"></p>
<p>然后执行下面的命令<br><code>$ npm install -g hexo-cli</code>，全局安装hexo的脚手架，安装以后我们就可以全局使用hexo这个命令了。安装成功后执行下面命令<code>hexo -v</code>，就可以看见如下效果。<br><img src="http://upload-images.jianshu.io/upload_images/1948637-f6c1ceeafe9de1d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hexo安装成功.png"></p>
<p>接着执行下面命令<code>npm install hexo --save</code></p>
<p>然后新建一个文件夹比如hexo，在该文件夹下打开Git(即Git bash here)，执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo init </div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>不出问题的话，该文件夹下面会新增这些文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-a9604272a538c58f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hexo_init.png"></p>
<h3 id="3-安装hexo服务器"><a href="#3-安装hexo服务器" class="headerlink" title="3 安装hexo服务器"></a>3 安装hexo服务器</h3><p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 <a href="https://github.com/hexojs/hexo-server" target="_blank" rel="external">hexo-server</a> 才能使用。执行命令<code>$ npm install hexo-server --save</code>。这样安装好hexo服务器以后，我们就可以启动服务器了。执行命令<code>$ hexo server</code>，然后在浏览器输入网址<strong><a href="http://127.0.0.1:4000/" target="_blank" rel="external">http://127.0.0.1:4000/</a></strong>,就可以正常访问了。效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-762b47f41c85b29e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地效果.png">。</p>
<p>OK！现在本地已经没问题了，接下来就是要把它部署到远程服务器上了。</p>
<h3 id="3-建立GitHub-pages"><a href="#3-建立GitHub-pages" class="headerlink" title="3  建立GitHub pages"></a>3  建立GitHub pages</h3><p>新建一个github仓库</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-e9ad42417d0f33d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new_repository.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-ac753802c8884e86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitHub_pages建立.png"></p>
<p>这个仓库比较特殊，它要按照如下格式进行命名：你的GitHub用户昵称.github.io。新建好这个仓库后，见如下效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-82a49dd72ededad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="djlxs.github.io.png"></p>
<p>然后点击settings选项，向下翻到Git Pages选项</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-84fbadde099f3129.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入主题前Git_pages.png"></p>
<p>上面有一个提示信息</p>
<blockquote>
<p>GitHub Pages is currently disabled. You must first add content to your repository before you can publish a GitHub Pages site</p>
</blockquote>
<p>我们此时访问<a href="https://djlxs.github.io/" target="_blank" rel="external">https://djlxs.github.io/</a> 是会报404的，因为没有内容，我们可以点击下面的Choose a theme按钮，选择一个主题后，在访问<a href="https://djlxs.github.io/" target="_blank" rel="external">https://djlxs.github.io/</a> ，就可以了。此时看看GitHub Pages选项已经变成</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-ef566fc26d0cedcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择主题后.png"><br>上面有个提示信息</p>
<blockquote>
<p>Your GitHub Pages site is currently being built from the master<br> branch</p>
</blockquote>
<p>OK啦</p>
<h3 id="4-配置SSH公钥"><a href="#4-配置SSH公钥" class="headerlink" title="4 配置SSH公钥"></a>4 配置SSH公钥</h3><p>配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下：</p>
<p>第一步、看看是否存在SSH密钥(keys)<br>首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/. ssh</div></pre></td></tr></table></figure>
<p>检查你本机用户home目录下是否存在.ssh目录<br>如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。</p>
<p>第二步、创建一对新的SSH密钥(keys)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #这将按照你提供的邮箱地址，创建一对密钥</div></pre></td></tr></table></figure>
<p>直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如<code>/c/Users/you/.ssh/github_rsa</code><br>接着，根据提示，你需要输入密码和确认密码,在这里我们直接enter，不用输入密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</div><div class="line">Enter same passphrase again: [Type passphrase again]</div></pre></td></tr></table></figure>
<p>输入完成之后，屏幕会显示如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key </div><div class="line">has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint </div><div class="line">is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</div></pre></td></tr></table></figure>
<p>第三步、在GitHub账户中添加你的公钥<br>运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clip &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>
<p>接着：<br>登陆GitHub,进入你的Account Settings.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-2a9b043895299590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add_SSH_key.png"></p>
<p>第四步、测试<br>可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>成功后你会看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi djlxs! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>
<p>第五步、设置用户信息<br>现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;djlxs&quot;//用户名</div><div class="line">$ git config --global user.email &quot;djlxs@gmail.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure>
<h3 id="5-将本地文件同步至GitHub"><a href="#5-将本地文件同步至GitHub" class="headerlink" title="5 将本地文件同步至GitHub"></a>5 将本地文件同步至GitHub</h3><p><img src="http://upload-images.jianshu.io/upload_images/1948637-badcf3287146813f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="clone_https.png"></p>
<p>到新建的仓库下面复制HTTPS地址，然后打开本地hexo文件夹下的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-53f92f31dd7c739c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_config.jpg"></p>
<p>填入以下信息：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-d7c3768113ba4bc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add_config.jpg"></p>
<p>然后在命令窗口执行下面命令,安装相关部署插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>安装完成后，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d -g</div></pre></td></tr></table></figure>
<p>此时会让你输入GitHub的账号和密码，输入后在浏览器中输入 <a href="https://djlxs.github.io/" target="_blank" rel="external">https://djlxs.github.io/</a> 应该就可以访问了。</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>首先去<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo皮肤网站</a>,选择一款进入它的GitHub地址然后将clone的文件移动到<strong>themes</strong>文件夹下。然后修改<strong>_config.yml</strong>文件中的theme为你所选择的主题的名称即可。然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>现在本地看看主题皮肤是否已经更换过来，然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d -g</div></pre></td></tr></table></figure>
<p>同步至GitHub，刷新即可</p>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>首先在万网上购买自己的域名，然后进入管理界面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-b4d8e0c05fc2fe50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名解析.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-6ffad7b818b55492.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名解析内容.jpg"></p>
<p>然后在source文件夹下建立一个CNAME文件(没有后缀名)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-db064d9b5ef4c125.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CNAME文件.jpg"><br>然后执行</p>
<p>CNAME:是提供别名解析，就是说可以从一个域名解析绑定到另一个域名。 例如：<code>http://djlxs.github.io</code>  解析绑定到 <code>http://djl.pub</code>。<br>其中主机记录<strong><em>www</em></strong>代表一个二级域名此时输入<code>http://www.djl.pub</code>是可以正常访问的。如果主机记录是<strong><em>@</em></strong>代表直接输入<code>http://djl.pub</code>是可以访问的<br>一般情况下这两种方式我们都会添加，所以你在浏览器地址栏中输入<code>http://djl.pub</code>和<code>http://www.djl.pub</code>跳到是同一个页面。</p>
<p>A:提供的是一种IP地址解析到你所买的域名的解析方式。例如：<code>151.101.24.133</code>  解析到 <code>djl.pub</code></p>
<p>在这里我用的是阿里云自带的DNS服务器，当然你也可以使用其他第三方DNS服务器。例如：<a href="https://www.dnspod.cn/" target="_blank" rel="external">dnspod</a>,添加解析记录的方式一样<br>但是这里要记得在你购买域名的网站上更改默认的DNS服务商，以下以万网（域名提供商）和dnspod（域名解析服务商）为例</p>
<p>首先进入控制台进入域名管理，找到相应域名点击<strong>管理</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-1dbf77201fec45d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名管理控制台.jpg"></p>
<p>点击修<strong>改DNS</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-ea78ba366c068ee3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改DNS服务器.jpg"></p>
<p>将以下内容复制粘贴进下图的内容框中保存，即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f1g1ns1.dnspod.net</div><div class="line">f1g1ns2.dnspod.net</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948637-baad0040dbc4dae9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更改DNS服务器.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d -g</div></pre></td></tr></table></figure>
<p>同步至GitHub即可，至此hexo博客搭建基本就大功告成。下面推荐一个工具<a href="https://github.com/nihgwu/hexo-hey" target="_blank" rel="external">hexo-hey</a></p>
<p><a href="https://my.oschina.net/ryaneLee/blog/638440" target="_blank" rel="external">小白独立搭建博客–Github Pages和Hexo简明教程</a></p>
<p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">hexo中文文档</a></p>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p><img src="http://upload-images.jianshu.io/upload_images/1948637-f354427a1d5932cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="问题01.jpg"></p>
<p>解决办法:<a href="https://segmentfault.com/q/1010000003734223" target="_blank" rel="external">参考链接</a>、<a href="https://github.com/hexojs/hexo/issues/1503" target="_blank" rel="external">参考链接</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果你只是想搭建一个自己的博客，绑定自己的域名写写文章，不想自己动手添加其他功能（评论、分享、搜索），那么选择<br>一款好的皮肤就很重要，因为有的皮肤早已经帮你集成好了，只需要动手简单的改改配置文件就行，在这里给大家推荐一款皮肤<br>可能样式有些过于花哨，不过这些都可以自己调，功能很全，文档也比较全。<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">github地址</a></p>
<p>这是我在新的博客上面的第一篇文章，欢迎大家访问我的博客。<a href="http://djl.pub/">DJL箫氏</a></p>
]]></content>
    </entry>
    
  
  
</search>
